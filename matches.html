<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Matches – TheCricketBoss</title>

  <link rel="stylesheet" href="styles/global.css"/>
  <link rel="stylesheet" href="css/matches.css"/>

  <script type="module" src="js/smooth-ui.js"></script>

  <style>
    /* ------- Layout & centering ------- */
    main{max-width:980px;margin:0 auto;padding:0 12px}
    h2{margin-top:22px}

    .match-list{
      display:flex;
      flex-direction:column;
      align-items:center; /* center every card */
    }

    .match-card{
      background:#111;border-radius:12px;padding:12px;margin:14px 0;border:1px solid #222;
      width:100%; max-width:680px;  /* nice centered width */
    }

    .match-head{
      display:flex;align-items:center;gap:8px;justify-content:space-between;margin-bottom:8px
    }

    .badge{font-size:.7rem;padding:4px 8px;border-radius:999px;border:1px solid #333;letter-spacing:.02em}
    .badge-league{background:#1e293b;color:#cbd5e1}
    .badge-friendly{background:#1b4332;color:#d1fae5}

    .chip{font-size:.7rem;padding:4px 8px;border-radius:6px}
    .chip-live{background:#b91c1c;color:#fff}
    .chip-done{background:#334155;color:#e2e8f0}
    .chip-upcoming{background:#0f766e;color:#ecfeff}

    .start{font-size:.8rem;opacity:.8}

    .match-body{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .team{display:flex;flex-direction:column;align-items:center;gap:6px;width:38%}
    .team img{width:56px;height:56px;border-radius:50%;object-fit:cover;background:#0b0b0b;border:1px solid #1f2937}
    .name{font-weight:600;text-align:center}
    .name a{color:#8affc3;text-decoration:none}
    .name a:hover{text-decoration:underline}
    .ovr { font-size:.85rem; color:#cbd5e1; opacity:.95; margin-top:4px; display:flex; align-items:center; gap:8px; }
    .ovr img { width:22px; height:22px; display:block; border-radius:0; object-fit:contain; border:none; }
    .vs{width:24%;text-align:center;opacity:.8}
    .score{margin-top:6px;text-align:center;font-weight:800}
    .subscore{margin-top:10px;text-align:center;font-size:.95rem;opacity:.95}
    .hidden-score{opacity:.6;font-weight:500}
    .empty{opacity:.7;padding:16px;border:1px dashed #333;border-radius:10px;margin:8px 0; width:100%; max-width:680px; text-align:center}

    /* ensure OVR image inside .team doesn't inherit circular style */
    .team .ovr-img { border-radius: 0 !important; width:22px; height:22px; object-fit:contain; }
  </style>
</head>
<body>
  <div id="top-bar"></div>

  <main>
    <h2>Live Matches</h2>
    <div id="live-matches" class="match-list"></div>

    <h2>Upcoming Matches</h2>
    <div id="upcoming-matches" class="match-list"></div>

    <h2>Completed Matches</h2>
    <div id="completed-matches" class="match-list"></div>
  </main>

  <div id="bottom-nav"></div>

  <script type="module">
    import { loadSmoothUI } from './js/smooth-ui.js';
    loadSmoothUI('top-bar', 'bottom-nav');
  </script>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

    const supabase = createClient(
      "https://iukofcmatlfhfwcechdq.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml1a29mY21hdGxmaGZ3Y2VjaGRxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM0NTczODQsImV4cCI6MjA2OTAzMzM4NH0.XMiE0OuLOQTlYnQoPSxwxjT3qYKzINnG6xq8f8Tb_IE"
    );

    const $ = (id) => document.getElementById(id);

    /* ---------- Utilities ---------- */
    function formatDateTime(ts) {
      if (!ts) return "";
      const d = new Date(ts);
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      const h24 = d.getHours();
      const hh = String(h24 % 12 || 12).padStart(2, "0");
      const min = String(d.getMinutes()).padStart(2, "0");
      const ampm = h24 >= 12 ? "PM" : "AM";
      return `${dd}-${mm}-${yyyy}, ${hh}:${min} ${ampm}`;
    }

    // badge now accepts a boolean or the original kind string
    const badge = (kindOrRow) => {
      const isLeague = typeof kindOrRow === 'object' ? (!!kindOrRow.league_id || kindOrRow.kind === 'league') : (kindOrRow === 'league');
      return `<span class="badge ${isLeague ? 'badge-league' : 'badge-friendly'}">${isLeague ? 'League' : 'Friendly'}</span>`;
    };

    function isFrontEndLive(m) {
      if (m.status === 'completed' || m.status === 'cancelled') return false;
      // fallback: if kickoff time is in past => consider live/started
      if (!m.kickoff_at && !m.scheduled_at && !m.date) return false;
      const now = Date.now();
      const ko = new Date(m.kickoff_at || m.scheduled_at || m.date).getTime();
      return now >= ko;
    }

    const statusChip = (m) => {
      const live = isFrontEndLive(m);
      const cls = live ? 'chip-live' : (m.status === 'completed' ? 'chip-done' : 'chip-upcoming');
      const txt = live ? 'LIVE' : (m.status === 'completed' ? 'Completed' : 'Scheduled');
      return `<span class="chip ${cls}">${txt}</span>`;
    };

    /* ---------- Robust parsing & mapping ---------- */
    const toJSON = (v)=> (typeof v === 'string' ? safeParse(v) : v);
    function safeParse(s){ try { return JSON.parse(s); } catch { return null; } }

    const numOrNull = (v)=> Number.isFinite(Number(v)) ? Number(v) : null;
    const nOrU = (v)=> Number.isFinite(Number(v)) ? Number(v) : undefined;

    function oversFromBalls(balls){
      if (!Number.isFinite(balls) || balls < 0) return null;
      const O = Math.floor(balls/6), B = balls%6;
      return `${O}.${B}`;
    }

    function formatScoreNoWk(t){
      if (!t || t.runs == null) return '—';
      return `${t.runs}${t.overs ? ` (${t.overs})` : ''}`;
    }

    function buildChaseText(result){
      const r = toJSON(result) || {};
      if (r.target != null && r.balls_left != null) {
        const req = Number(r.target) - Number(r.current_runs ?? r.runs ?? 0);
        const left = Number(r.balls_left);
        if (Number.isFinite(req) && Number.isFinite(left))
          return `${Math.max(req,0)} runs required from ${Math.max(left,0)} balls`;
      }
      return '';
    }

    function completedResultLine(m, homeName, awayName){
      if (m.winner_team_id) {
        const winner = (m.winner_team_id === m.home_team_id) ? homeName
                      : (m.winner_team_id === m.away_team_id) ? awayName : 'Winner';
        return `${winner} won the match`;
      }
      return 'Match completed';
    }

    /**
     * Extract totals for home & away with correct mapping even when the away team bats first.
     * Priority:
     *   1) result.home / result.away
     *   2) result.innings[] with team_id
     *   3) result.innings[] (no team_id) + toss (result.toss or sim_state.toss)
     *   4) sim_state.i1/i2 + toss (fallback for older data)
     */
    function extractTotalsMapped(result, homeId, awayId, sim_state){
      const r = toJSON(result) || {};
      const sim = toJSON(sim_state) || {};

      // 1) explicit home/away blocks
      if (r.home || r.away) {
        const home = r.home ? {
          runs: numOrNull(r.home.runs ?? r.home.score),
          overs: r.home.overs ?? oversFromBalls(nOrU(r.home.balls))
        } : {runs:null, overs:null};
        const away = r.away ? {
          runs: numOrNull(r.away.runs ?? r.away.score),
          overs: r.away.overs ?? oversFromBalls(nOrU(r.away.balls))
        } : {runs:null, overs:null};
        return {home, away};
      }

      // helper to normalize totals from a generic innings block
      const toTotals = (inn) => ({
        runs: numOrNull(inn?.totals?.runs ?? inn?.runs ?? inn?.score),
        overs: inn?.totals?.overs ?? inn?.overs ?? oversFromBalls(nOrU(inn?.totals?.balls ?? inn?.balls))
      });

      // 2) innings with team ids
      if (Array.isArray(r.innings) && r.innings.some(x => x && (x.team_id!=null || x.team!=null))) {
        let home = {runs:null, overs:null}, away = {runs:null, overs:null};
        for (const inn of r.innings) {
          const tid = String(inn.team_id ?? inn.team ?? '');
          const totals = toTotals(inn);
          if (String(homeId) === tid) home = totals;
          else if (String(awayId) === tid) away = totals;
        }
        return {home, away};
      }

      // Function: decide i1 team from a toss object
      const decideTeamsFromToss = (tossObj) => {
        if (!tossObj || !tossObj.winner || !tossObj.decision) return null;
        const winner = String(tossObj.winner);
        const loser  = (String(homeId) === winner) ? String(awayId) : String(homeId);
        const i1Team = (String(tossObj.decision).toLowerCase() === 'bat') ? winner : loser;
        const i2Team = (i1Team === String(homeId)) ? String(awayId) : String(homeId);
        return {i1Team, i2Team};
      };

      // 3) innings[] without team_id + toss
      if (Array.isArray(r.innings) && r.innings.length) {
        const order = decideTeamsFromToss(r.toss) || decideTeamsFromToss(sim.toss);
        if (order) {
          const i1 = toTotals(r.innings[0] || {});
          const i2 = toTotals(r.innings[1] || {});
          const home = (String(homeId) === order.i1Team) ? i1 : i2;
          const away = (String(awayId)  === order.i1Team) ? i1 : i2;
          return {home, away};
        }
      }

      // 4) sim_state i1/i2 + toss (older data where only sim_state has detail)
      if (sim.i1 || sim.i2) {
        const order = decideTeamsFromToss(sim.toss);
        if (order) {
          const i1 = { runs: numOrNull(sim.i1?.runs), overs: oversFromBalls(nOrU(sim.i1?.balls)) };
          const i2 = { runs: numOrNull(sim.i2?.runs), overs: oversFromBalls(nOrU(sim.i2?.balls)) };
          const home = (String(homeId) === order.i1Team) ? i1 : i2;
          const away = (String(awayId)  === order.i1Team) ? i1 : i2;
          return {home, away};
        }
      }

      // default
      return {home:{runs:null, overs:null}, away:{runs:null, overs:null}};
    }

    /* ---------- TEAM OVR helpers (copied/adapted from public-profile.html) */
    const TEAM_PLAYERS_CACHE = new Map();
    const TEAM_LINEUP_CACHE = new Map();
    async function fetchPlayersForTeam(teamId){
      if (!teamId) return [];
      if (TEAM_PLAYERS_CACHE.has(teamId)) return TEAM_PLAYERS_CACHE.get(teamId);
      const { data } = await supabase.from('players').select('id,name,role,batting,bowling,keeping').eq('team_id', teamId);
      const arr = (data || []).map(p=>({ ...p }));
      TEAM_PLAYERS_CACHE.set(teamId, arr);
      return arr;
    }
    async function fetchLineupForTeam(teamId){
      if (!teamId) return null;
      if (TEAM_LINEUP_CACHE.has(teamId)) return TEAM_LINEUP_CACHE.get(teamId);
      const { data } = await supabase.from('lineups').select('playing_xi,keeper,captain,batting_order,bowling_order').eq('team_id', teamId).maybeSingle();
      TEAM_LINEUP_CACHE.set(teamId, data || null);
      return data || null;
    }

    function toNum(v){ return Number.isFinite(Number(v)) ? Number(v) : 0; }

    function pickByLineupOrAuto(allPlayers, lineup){
      const byId = new Map(allPlayers.map(p=>[p.id,p]));
      let pool = [];
      if (lineup?.playing_xi?.length){
        pool = lineup.playing_xi.map(id=>byId.get(id)).filter(Boolean);
      }else{
        pool = [...allPlayers].sort((a,b)=>
          (toNum(b.batting)+toNum(b.bowling)+toNum(b.keeping)) -
          (toNum(a.batting)+toNum(a.bowling)+toNum(a.keeping))
        ).slice(0, Math.min(11, allPlayers.length));
      }
      // determine keeper
      let wk = lineup?.keeper ? byId.get(lineup.keeper) : null;
      if (!wk){
        wk = [...(pool.length?pool:allPlayers)].sort((a,b)=>toNum(b.keeping)-toNum(a.keeping))[0] || null;
      }
      const poolNoWK = (pool.length?pool:allPlayers).filter(p=>!wk || p.id !== wk.id);
      const ar = [...poolNoWK].sort((a,b)=>(toNum(b.batting)+toNum(b.bowling)) - (toNum(a.batting)+toNum(a.bowling)))[0] || null;
      const bats = [...(pool.length?pool:allPlayers)].filter(p=>!wk || p.id!==wk.id).sort((a,b)=>toNum(b.batting)-toNum(a.batting)).slice(0,4);
      const bowls = [...(pool.length?pool:allPlayers)].filter(p=>!wk || p.id!==wk.id).sort((a,b)=>toNum(b.bowling)-toNum(a.bowling)).slice(0,5);
      return { wk, ar, batters: bats, bowlers: bowls };
    }

    function computeRatings(sel){
      const batSum = (sel.batters||[]).reduce((s,p)=>s+toNum(p.batting),0) + (sel.wk?toNum(sel.wk.batting):0) + (sel.ar?toNum(sel.ar.batting):0);
      const batCount = (sel.batters?.length || 0) + (sel.wk?1:0) + (sel.ar?1:0);
      const batAvg = batCount ? (batSum / batCount) : 0;

      const ballSum = (sel.bowlers||[]).reduce((s,p)=>s+toNum(p.bowling),0) + (sel.ar?toNum(sel.ar.bowling):0);
      const ballCount = (sel.bowlers?.length || 0) + (sel.ar?1:0);
      const ballAvg = ballCount ? (ballSum / ballCount) : 0;

      const wkVal = sel.wk ? toNum(sel.wk.keeping) : 0;
      const ovr = (batAvg + ballAvg + wkVal) / 3;
      return { bat: batAvg, ball: ballAvg, wk: wkVal, ovr };
    }

    const TEAM_OVR_CACHE = new Map();
    async function computeTeamOVR(teamId){
      if (!teamId) return null;
      if (TEAM_OVR_CACHE.has(teamId)) return TEAM_OVR_CACHE.get(teamId);
      const players = await fetchPlayersForTeam(teamId);
      const lineup = await fetchLineupForTeam(teamId);
      const sel = pickByLineupOrAuto(players, lineup);
      const ratings = computeRatings(sel);
      TEAM_OVR_CACHE.set(teamId, ratings.ovr);
      return ratings.ovr;
    }

    /* ---------- Card creation (async) ---------- */
    async function createCardAsync(m){
      const homeLogo = m.home_logo || 'images/logo.png';
      const awayLogo = m.away_logo || 'images/logo.png';
      const when = formatDateTime(m.kickoff_at || m.scheduled_at || m.date);
      const live = isFrontEndLive(m);

      const homeName = m.home_team_name || 'Home';
      const awayName = m.away_team_name || 'Away';
      const homeNameHtml = `<a href="public-profile.html?team=${m.home_team_id}">${homeName}</a>`;
      const awayNameHtml = `<a href="public-profile.html?team=${m.away_team_id}">${awayName}</a>`;

      const { home:homeTotals, away:awayTotals } =
        extractTotalsMapped(m.result, m.home_team_id, m.away_team_id, m.sim_state);

      const homeScore = (live || m.status==='completed') ? formatScoreNoWk(homeTotals) : '—';
      const awayScore = (live || m.status==='completed') ? formatScoreNoWk(awayTotals) : '—';

      const chaseText  = live ? buildChaseText(m.result) : '';
      const resultText = (!live && m.status==='completed') ? completedResultLine(m, homeName, awayName) : '';

      // Compute OVRs (cached where possible). Do them in parallel.
      const [homeOvr, awayOvr] = await Promise.all([ computeTeamOVR(m.home_team_id), computeTeamOVR(m.away_team_id) ]);

      const div = document.createElement('div');
      div.className = 'match-card';
      div.innerHTML = `
        <div class="match-head">
          ${badge(m)}
          <div class="start">${when}</div>
          ${statusChip(m)}
        </div>

        <div class="match-body">
          <div class="team">
            <img src="${homeLogo}" alt="${homeName}"/>
            <div class="name">${homeNameHtml}</div>
            <div class="ovr"><img class="ovr-img" src="assets/rating/ovr.png" alt="OVR"/> ${homeOvr != null ? Number(homeOvr).toFixed(1) : '—'}</div>
            <div class="score ${live || m.status==='completed' ? '' : 'hidden-score'}">${homeScore}</div>
          </div>

          <div class="vs">vs</div>

          <div class="team">
            <img src="${awayLogo}" alt="${awayName}"/>
            <div class="name">${awayNameHtml}</div>
            <div class="ovr"><img class="ovr-img" src="assets/rating/ovr.png" alt="OVR"/> ${awayOvr != null ? Number(awayOvr).toFixed(1) : '—'}</div>
            <div class="score ${live || m.status==='completed' ? '' : 'hidden-score'}">${awayScore}</div>
          </div>
        </div>

        ${live && chaseText ? `<div class="subscore">${chaseText}</div>` : ''}
        ${(!live && m.status==='completed') ? `<div class="subscore">${resultText}</div>` : ''}
      `;

      // New routing logic: league vs friendly, running vs not
      const isLeague = !!m.league_id || m.kind === 'league';
      const running = ((m.status||'').toLowerCase() === 'running') || (m.started_at && !m.finished_at);

      let dest = null;
      if (isLeague) {
        dest = running ? `league-match.html?id=${encodeURIComponent(m.id)}` : `league-replay.html?id=${encodeURIComponent(m.id)}`;
      } else {
        dest = running ? `friendly-match.html?id=${encodeURIComponent(m.id)}` : `friendly-replay.html?id=${encodeURIComponent(m.id)}`;
      }

      // Attach click handler only when we have a destination to go to
      if (dest) {
        div.onclick = () => { window.location.href = dest; };
        div.style.cursor = 'pointer';
      } else {
        div.style.cursor = 'default';
      }

      return div;
    }

    /* ---------- Feed (uses async card creation) ---------- */
    async function renderFeed() {
      // NOTE: your RPC get_matches_feed_for_user already returns a mixed list with fields used above
      const { data, error } = await supabase.rpc('get_matches_feed_for_user');
      if (error) { console.error(error); return; }

      const list = data ?? [];

      const liveL  = list.filter(m => isFrontEndLive(m))
                         .sort((a,b)=> new Date(b.kickoff_at || b.scheduled_at || b.date) - new Date(a.kickoff_at || a.scheduled_at || a.date));
      const upcL   = list.filter(m => !isFrontEndLive(m) && m.status !== 'completed' && m.status !== 'cancelled')
                         .sort((a,b)=> new Date(a.kickoff_at || a.scheduled_at || a.date) - new Date(b.kickoff_at || b.scheduled_at || b.date));
      const doneL  = list.filter(m => m.status === 'completed')
                         .sort((a,b)=> new Date(b.kickoff_at || b.scheduled_at || b.date) - new Date(a.kickoff_at || a.scheduled_at || a.date));

      $('live-matches').innerHTML = '';
      if (!liveL.length) $('live-matches').innerHTML = '<div class="empty">No live matches</div>';
      for (const m of liveL) {
        try {
          const cardEl = await createCardAsync(m);
          $('live-matches').appendChild(cardEl);
        } catch (e) {
          console.error('card render error', e, m);
        }
      }

      $('upcoming-matches').innerHTML = '';
      if (!upcL.length) $('upcoming-matches').innerHTML = '<div class="empty">No upcoming matches</div>';
      for (const m of upcL) {
        try {
          const cardEl = await createCardAsync(m);
          $('upcoming-matches').appendChild(cardEl);
        } catch (e) {
          console.error('card render error', e, m);
        }
      }

      $('completed-matches').innerHTML = '';
      if (!doneL.length) $('completed-matches').innerHTML = '<div class="empty">No completed matches yet</div>';
      for (const m of doneL) {
        try {
          const cardEl = await createCardAsync(m);
          $('completed-matches').appendChild(cardEl);
        } catch (e) {
          console.error('card render error', e, m);
        }
      }
    }

    async function load(){
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) { location.href = "login.html"; return; }

      await renderFeed();
      setInterval(renderFeed, 10000);

      const { data: myTeam } = await supabase
        .from('teams').select('id').eq('owner_id', user.id).maybeSingle();
      if (myTeam?.id) {
        supabase.channel('matches-feed')
          .on('postgres_changes', { event:'UPDATE', schema:'public', table:'matches',  filter:`home_team_id=eq.${myTeam.id}` }, renderFeed)
          .on('postgres_changes', { event:'UPDATE', schema:'public', table:'matches',  filter:`away_team_id=eq.${myTeam.id}` }, renderFeed)
          .on('postgres_changes', { event:'UPDATE', schema:'public', table:'fixtures', filter:`home_team_id=eq.${myTeam.id}` }, renderFeed)
          .on('postgres_changes', { event:'UPDATE', schema:'public', table:'fixtures', filter:`away_team_id=eq.${myTeam.id}` }, renderFeed)
          .subscribe();
      }
    }

    load();
  </script>
</body>
</html>


