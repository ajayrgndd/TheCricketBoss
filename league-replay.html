<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>League Replay ‚Äì TheCricketBoss</title>
  <link rel="stylesheet" href="styles/global.css"/>
  <style>
    body{background:#0b0f16;color:#e7ecf3;font-family:system-ui;margin:0}
    .wrap{max-width:980px;margin:0 auto;padding:16px}
    .head{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;margin:10px 0}
    .badge{font-size:.75rem;padding:4px 10px;border-radius:999px;border:1px solid #26314b;background:#0f1522}
    .chip-done{background:#334155;color:#e2e8f0;border:1px solid #3b475f;border-radius:6px;padding:4px 10px;font-size:.75rem}
    .muted{opacity:.75}
    .tabs{display:flex;gap:6px;border-bottom:2px solid #1d263a;position:sticky;top:48px;background:#0b0f16;z-index:5}
    .tabs button{flex:1;padding:10px 8px;background:#10151f;color:#cfe7dc;border:none;border-radius:6px 6px 0 0;cursor:pointer;font-weight:700;letter-spacing:.02em}
    .tabs button.active{background:#00e676;color:#000}
    .panel{display:none}
    .panel.show{display:block}
    .card{background:#121825;border:1px solid #1d263a;border-radius:12px;padding:12px;margin:14px 0}
    table{width:100%;border-collapse:collapse}
    th,td{border:1px solid #2a344a;padding:8px;text-align:center;vertical-align:top}
    th{background:#192238}
    td.left{text-align:left}
    .score-strip{display:flex;justify-content:space-between;align-items:center;background:#ff7a00;color:#000;font-weight:800;padding:10px 12px;border-radius:8px;margin:10px 0}
    .score-strip .big{font-size:1.05rem;display:flex;gap:12px;align-items:center}
    .feed{display:flex;flex-direction:column;gap:8px}
    .ball{padding:12px;border:1px dashed #26314b;border-radius:10px;background:#0f1522}
    .ball .head{font-weight:700;margin-bottom:6px}
    .tag{font-size:.7rem;border-radius:6px;padding:2px 8px;border:1px solid #334155;background:#152035;margin-left:8px}
    .wkt{background:#3a0e14;border-color:#521b24;color:#ffd6d6}
    .b4{background:#123d27;border-color:#1c593a;color:#b8ffd6}
    .b6{background:#0e2e57;border-color:#1a4886;color:#cfe8ff}
    .sub{opacity:.9;margin-top:4px}
    .skillbar{display:flex;gap:2px;margin-top:4px}
    .skillbar .seg{width:6px;height:10px;border-radius:2px;box-shadow:0 0 0 1px rgba(0,0,0,.25) inset}
    .namecell{display:flex;flex-direction:column;align-items:flex-start;gap:2px}
    .nm{line-height:1.1}
    .toss-line .toss-banner{background:#222a68;color:#fff;text-align:center;font-weight:bold;padding:10px;margin:8px 0;border-radius:6px;font-size:16px;letter-spacing:.5px}
    .controls button{margin-right:8px}
  </style>
</head>
<body>
  <div id="top-bar"></div>

  <div class="wrap">
    <div class="head">
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <span class="badge">League</span>
        <span id="replay-date" class="muted">--</span>
      </div>
      <span id="status-chip" class="chip-done">--</span>
    </div>

    <h2 id="match-title">Home vs Away</h2>
    <div class="muted" id="match-sub">Kickoff ‚Äî --</div>

    <div class="tabs" style="margin-top:12px">
      <button id="tab-replay">REPLAY</button>
      <button id="tab-score" class="active">SCORECARD</button>
      <button id="tab-summary">SUMMARY</button>
    </div>

    <!-- REPLAY -->
    <section id="replay-panel" class="panel">
      <div class="card controls">
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <button id="btn-play">‚ñ∂ Play</button>
          <button id="btn-pause" disabled>‚è∏ Pause</button>
          <button id="btn-next">‚è© Next ball</button>
          <button id="btn-skip-over">‚è≠ Next over</button>
          <button id="btn-restart">üîÅ Restart</button>
          <div style="flex:1"></div>
          <label>Speed
            <select id="speed">
              <option value="1200">Slow</option>
              <option value="700" selected>Normal</option>
              <option value="350">Fast</option>
            </select>
          </label>
        </div>
      </div>

      <!-- toss banner placeholder for REPLAY -->
      <div id="toss-banner-inline"></div>

      <!-- Mini score strip (always visible on REPLAY tab) -->
      <div class="score-strip">
        <div class="big" id="mini-a"><span id="mini-a-name">Team A</span> <span id="mini-a-score">0/0 - 0.0 ov</span></div>
        <div class="big" id="mini-b"><span id="mini-b-name">Team B</span> <span id="mini-b-score">0/0 - 0.0 ov</span></div>
      </div>

      <div class="card">
        <div id="comm-feed" class="feed"></div>
      </div>
    </section>

    <!-- SCORECARD -->
    <div id="toss-banner-score"></div>

    <section id="score-panel" class="panel show">
      <div class="card">
        <div id="headline-a" style="font-weight:800;font-size:1.05rem;">‚Äî</div>
        <div id="headline-b" style="font-weight:800;font-size:1.05rem;margin-top:6px;">‚Äî</div>
      </div>

      <div id="sc-in1" class="card">
        <h3 id="in1-name">Innings 1</h3>
        <div class="muted" id="in1-total">--</div>
        <div style="margin-top:10px"></div>
        <div><strong>Batting</strong></div>
        <table style="margin-top:6px">
          <thead><tr><th class="left">Batsman</th><th class="left">Dismissal</th><th>R</th><th>B</th><th>4s</th><th>6s</th><th>SR</th></tr></thead>
          <tbody id="bat1"></tbody>
        </table>
        <div style="height:10px"></div>
        <div><strong>Bowling</strong></div>
        <table style="margin-top:6px">
          <thead><tr><th class="left">Bowler</th><th>O</th><th>R</th><th>W</th><th>Eco</th></tr></thead>
          <tbody id="bowl1"></tbody>
        </table>
      </div>

      <div id="sc-in2" class="card">
        <h3 id="in2-name">Innings 2</h3>
        <div class="muted" id="in2-total">--</div>
        <div style="margin-top:10px"></div>
        <div><strong>Batting</strong></div>
        <table style="margin-top:6px">
          <thead><tr><th class="left">Batsman</th><th class="left">Dismissal</th><th>R</th><th>B</th><th>4s</th><th>6s</th><th>SR</th></tr></thead>
          <tbody id="bat2"></tbody>
        </table>
        <div style="height:10px"></div>
        <div><strong>Bowling</strong></div>
        <table style="margin-top:6px">
          <thead><tr><th class="left">Bowler</th><th>O</th><th>R</th><th>W</th><th>Eco</th></tr></thead>
          <tbody id="bowl2"></tbody>
        </table>
      </div>
    </section>

    <!-- SUMMARY -->
    <section id="summary-panel" class="panel">
      <div class="card">
        <h3>Match Summary</h3>
        <div id="result-line" style="margin:6px 0 12px 0;font-weight:700"></div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
          <div style="background:#10151f;border:1px solid #22304b;border-radius:10px;padding:10px">
            <div id="sum-home-name" class="muted">Home</div>
            <div id="sum-home-score" style="font-size:1.1rem;font-weight:800">--/--</div>
            <div style="margin-top:8px;font-weight:700">Top Batters</div>
            <ul id="sum-home-topbat" style="margin:6px 0 0 18px;line-height:1.4"></ul>
            <div style="margin-top:8px;font-weight:700">Top Bowlers</div>
            <ul id="sum-home-topbowl" style="margin:6px 0 0 18px;line-height:1.4"></ul>
          </div>
          <div style="background:#10151f;border:1px solid #22304b;border-radius:10px;padding:10px">
            <div id="sum-away-name" class="muted">Away</div>
            <div id="sum-away-score" style="font-size:1.1rem;font-weight:800">--/--</div>
            <div style="margin-top:8px;font-weight:700">Top Batters</div>
            <ul id="sum-away-topbat" style="margin:6px 0 0 18px;line-height:1.4"></ul>
            <div style="margin-top:8px;font-weight:700">Top Bowlers</div>
            <ul id="sum-away-topbowl" style="margin:6px 0 0 18px;line-height:1.4"></ul>
          </div>
        </div>
      </div>
    </section>
  </div>

  <div id="bottom-nav"></div>

  <!-- Smooth UI loader (same pattern as other pages) -->
  <script type="module">
    import { loadSmoothUI } from "./js/smooth-ui.js";
    loadSmoothUI("top-bar","bottom-nav");
  </script>

  <!-- Replay logic (league table names) -->
  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

    const qs = new URLSearchParams(location.search);
    const fixtureId = qs.get("id");

    // adjust these values to your Supabase project like other pages
    const supabase = createClient(
      "https://iukofcmatlfhfwcechdq.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml1a29mY21hdGxmaGZ3Y2VjaGRxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM0NTczODQsImV4cCI6MjA2OTAzMzM4NH0.XMiE0OuLOQTlYnQoPSxwxjT3qYKzINnG6xq8f8Tb_IE"
    );

    /* UI refs */
    const titleEl = document.getElementById("match-title");
    const subEl = document.getElementById("match-sub");
    const replayDate = document.getElementById("replay-date");
    const statusChip = document.getElementById("status-chip");
    const headlineA = document.getElementById("headline-a");
    const headlineB = document.getElementById("headline-b");

    const in1Name = document.getElementById("in1-name");
    const in2Name = document.getElementById("in2-name");
    const in1Tot = document.getElementById("in1-total");
    const in2Tot = document.getElementById("in2-total");
    const bat1 = document.getElementById("bat1");
    const bat2 = document.getElementById("bat2");
    const bowl1 = document.getElementById("bowl1");
    const bowl2 = document.getElementById("bowl2");

    const miniAName = document.getElementById("mini-a-name");
    const miniAScore = document.getElementById("mini-a-score");
    const miniBName = document.getElementById("mini-b-name");
    const miniBScore = document.getElementById("mini-b-score");

    const commFeed = document.getElementById("comm-feed");
    const tossBannerInline = document.getElementById("toss-banner-inline");
    const tossBannerScore = document.getElementById("toss-banner-score");

    const resultLine = document.getElementById("result-line");
    const sumHomeName = document.getElementById("sum-home-name");
    const sumAwayName = document.getElementById("sum-away-name");
    const sumHomeScore = document.getElementById("sum-home-score");
    const sumAwayScore = document.getElementById("sum-away-score");
    const sumHomeTopBat = document.getElementById("sum-home-topbat");
    const sumAwayTopBat = document.getElementById("sum-away-topbat");
    const sumHomeTopBowl = document.getElementById("sum-home-topbowl");
    const sumAwayTopBowl = document.getElementById("sum-away-topbowl");

    /* tabs */
    const tabs = {
      replay: document.getElementById("tab-replay"),
      score: document.getElementById("tab-score"),
      summary: document.getElementById("tab-summary")
    };
    const panels = {
      replay: document.getElementById("replay-panel"),
      score: document.getElementById("score-panel"),
      summary: document.getElementById("summary-panel")
    };
    const activate = (k) => {
      ["replay","score","summary"].forEach(t=>{
        tabs[t].classList.toggle("active", t===k);
        panels[t].classList.toggle("show", t===k);
      });
    };
    activate("score");
    tabs.replay.onclick = ()=> activate("replay");
    tabs.score.onclick = ()=> activate("score");
    tabs.summary.onclick = ()=> activate("summary");

    /* controls */
    const btnPlay = document.getElementById("btn-play");
    const btnPause = document.getElementById("btn-pause");
    const btnNext = document.getElementById("btn-next");
    const btnOver = document.getElementById("btn-skip-over");
    const btnRestart = document.getElementById("btn-restart");
    const speedSel = document.getElementById("speed");

    let players = {};
    let names = {};
    let fixture = null;
    let balls = [];
    let shown = 0;
    let timer = null;
    let delay = 700;
    const liveBatRuns = new Map();

    /* palette + shortName helpers (same style as other pages) */
    const PALETTE = ["#f8f532","#f3e61c","#e9d60e","#d4cf10","#b0d022","#7ec14a","#49a769","#2f9ea6","#1d78c6","#1850a1","#1a2f7a","#5d2f7a","#a9483c","#cc1f1f"];
    function shortName(full){
      if(!full) return "‚Äî";
      const parts = String(full).trim().split(/\s+/).filter(Boolean);
      if(parts.length === 1) return parts[0];
      const last = parts.pop();
      const initials = parts.map(w => (w[0]||'').toUpperCase()).filter(Boolean).join(' ');
      return `${initials} ${last}`;
    }
    function nameWithBadges(pid){
      if(!pid) return "‚Äî";
      const p = players[pid];
      if(!p) return `Player ${String(pid).slice(0,8)}`;
      const nm = shortName(p.name);
      return nm;
    }
    function colorBarHTML(pid){
      const score = Math.max(0, (players[pid]?.batting||0) + (players[pid]?.bowling||0));
      const segs = Math.max(1, Math.min(PALETTE.length, Math.round((score/100)*PALETTE.length)));
      const blocks = PALETTE.slice(0,segs).map(c=>`<span class="seg" style="background:${c}"></span>`).join("");
      return `<div class="skillbar" title="Skill: ${score.toFixed(1)}">${blocks}</div>`;
    }
    function nameCell(pid, kind){
      return `<div class="namecell"><div class="nm">${nameWithBadges(pid)}</div>${colorBarHTML(pid)}</div>`;
    }

    /* utility aggregates */
    function isLegal(b){ const t = (b.delivery_type||'legal').toLowerCase(); return t !== 'wide' && t !== 'noball' && t !== 'toss' && t !== 'bye'; }
    function oversTxt(ballsCount){ return `${Math.floor(ballsCount/6)}.${ballsCount%6}`; }
    function overLabel(ball){ return `${(ball.over_number||0)-1}.${ball.ball_in_over||0}`; }
    function totals(list, inn){
      const arr = list.filter(b=>b.innings===inn);
      const legal = arr.filter(isLegal).length;
      return { runs: arr.reduce((s,b)=> s + (b.runs_scored||0) + (b.extras||0), 0), wkts: arr.reduce((s,b)=> s + (b.wicket?1:0),0), legal };
    }
    function aggBat(list, inn){
      const map = {};
      list.filter(b=>b.innings===inn).forEach(b=>{
        const id = b.striker_id; if(!id) return;
        const m = map[id] ||= {r:0,b:0,f:0,s:0};
        m.r += b.runs_scored||0;
        if (isLegal(b)) { m.b++; if (b.runs_scored===4) m.f++; if (b.runs_scored===6) m.s++; }
      });
      return map;
    }
    function aggBowl(list, inn){
      const map = {};
      list.filter(b=>b.innings===inn).forEach(b=>{
        const id = b.bowler_id; if(!id) return;
        const m = map[id] ||= {r:0,b:0,w:0};
        m.r += (b.runs_scored||0) + (b.extras||0);
        if (isLegal(b)) m.b++;
        const t = (b.dismissal_type||"").toLowerCase();
        if (b.wicket && t !== "runout" && t !== "run-out") m.w++;
      });
      return map;
    }
    function dismissalMap(list, inn){
      const map = {};
      list.filter(b=>b.innings===inn && b.wicket && b.dismissed_batsman_id).forEach(b=>{
        map[b.dismissed_batsman_id] = { type:(b.dismissal_type||"").toLowerCase(), bowler:b.bowler_id||null, fielder:b.fielder_id||null };
      });
      return map;
    }

    function rowBat(tbody, map, dm){
      tbody.innerHTML = "";
      Object.entries(map).forEach(([pid, st])=>{
        const nmCell = nameCell(pid);
        const sr = st.b ? ((st.r/st.b)*100).toFixed(1) : "0.0";
        let dis = "not out";
        const d = dm[pid];
        if (d) {
          const bow = nameWithBadges(d.bowler); const fld = nameWithBadges(d.fielder);
          if (d.type==="bowled") dis = `b ${bow}`;
          else if (d.type==="lbw") dis = `lbw b ${bow}`;
          else if (d.type==="caught") {
            if (d.fielder && d.bowler && d.fielder===d.bowler) dis = `c & b ${bow}`;
            else if (d.fielder) dis = `c ${fld} b ${bow}`;
            else dis = `c b ${bow}`;
          } else if (d.type==="runout"||d.type==="run-out") dis = d.fielder ? `run out (${nameWithBadges(d.fielder)})` : "run out";
          else dis = bow ? `b ${bow}` : "out";
        }
        tbody.insertAdjacentHTML("beforeend", `<tr><td class="left">${nmCell}</td><td class="left">${dis}</td><td>${st.r}</td><td>${st.b}</td><td>${st.f}</td><td>${st.s}</td><td>${sr}</td></tr>`);
      });
    }
    function rowBowl(tbody, map){
      tbody.innerHTML = "";
      Object.entries(map).forEach(([pid, st])=>{
        const nmCell = nameCell(pid);
        const ov = `${Math.floor(st.b/6)}.${st.b%6}`;
        const eco = st.b ? (st.r/(st.b/6)).toFixed(1) : "0.0";
        tbody.insertAdjacentHTML("beforeend", `<tr><td class="left">${nmCell}</td><td>${ov}</td><td>${st.r}</td><td>${st.w}</td><td>${eco}</td></tr>`);
      });
    }

    /* random sentence selector (fallback) */
    function pickVariant(b){
      const c = (b.commentary||"").trim();
      if (c && !/^runs?\s*:/i.test(c) && !/^out!?$/i.test(c)) return c;
      if (b.wicket) {
        const arr = ["Gone! Big breakthrough.","Edged and taken!","Bowled him!"];
        return arr[Math.floor(Math.random()*arr.length)];
      }
      const pools = {
        0:["Dot ball.","Beaten!","Good length ‚Äî no run."],
        1:["Just a single.","Nudged for one."],
        2:["They come back for two.","Comfortable two."],
        3:["All hustle ‚Äî three!","Good running ‚Äî three."],
        4:["FOUR! Crunched.","Pierces the gap ‚Äî four."],
        6:["SIX! Launched.","Into the stands ‚Äî six!"]
      };
      const p = Math.min(6, Math.max(0, b.runs_scored||0));
      const pool = pools[p] || ["Runs added."];
      return pool[Math.floor(Math.random()*pool.length)];
    }

    function ballHtml(b, extraLines=[]){
      const head = `Innings ${b.innings} ‚Ä¢ Over ${overLabel(b)}`;
      const bow = nameWithBadges(b.bowler_id);
      const bat = nameWithBadges(b.striker_id);
      const tags = [];
      if (b.wicket) tags.push('<span class="tag wkt">WICKET</span>');
      if (b.runs_scored===4) tags.push('<span class="tag b4">FOUR</span>');
      if (b.runs_scored===6) tags.push('<span class="tag b6">SIX</span>');
      const line = `Runs: ${b.runs_scored||0}, ${pickVariant(b)}`;
      const extras = extraLines.length ? `<div class="sub">${extraLines.join("<br/>")}</div>` : "";
      return `
        <div class="ball">
          <div class="head">${head}${tags.join('')}</div>
          <div><strong>${bow}</strong> to <strong>${bat}</strong></div>
          <div>${line}</div>
          ${extras}
        </div>`;
    }

    function updateMini(part){
      const t1 = totals(part,1), t2 = totals(part,2);
      const t1Name = names[battingFirst] || names[fixture.home_team_id] || "Team A";
      const t2Name = names[battingSecond] || names[fixture.away_team_id] || "Team B";
      miniAName.textContent = t1Name;
      miniAScore.textContent = `${t1.runs}/${t1.wkts} - ${oversTxt(t1.legal)} ov`;
      miniBName.textContent = t2Name;
      miniBScore.textContent = `${t2.runs}/${t2.wkts} - ${oversTxt(t2.legal)} ov`;
    }

    /* toss normalization and banner reuse (copied approach) */
    function tryParseJSON(v){ if(!v) return null; try{ return typeof v === 'string' ? JSON.parse(v) : v; }catch{ return null; } }
    function normalizeTossFromPayload(row){
      if(!row) return null;
      const resultObj = tryParseJSON(row.result) ?? row.result;
      const simObj = tryParseJSON(row.sim_state) ?? row.sim_state;
      if (row.toss_winner_team_id || row.toss_decision) return { winner_team_id: row.toss_winner_team_id||null, decision: row.toss_decision||null, text:null };
      if (row.toss) return { winner_team_id: row.toss.winner_team_id||row.toss.winner||null, decision: row.toss.decision||row.toss.elected||null, text: row.toss.text||null };
      if (resultObj && resultObj.toss) { const t = resultObj.toss; return { winner_team_id: t.winner_team_id||t.winner||null, decision: t.decision||t.elected||null, text: t.text||null }; }
      if (simObj && simObj.toss) { const t = simObj.toss; return { winner_team_id: t.winner_team_id||t.winner||null, decision: t.decision||t.elected||null, text: t.text||null }; }
      return null;
    }
    function renderTossBanner(matchRow, commentaryList){
      const normalized = normalizeTossFromPayload(matchRow);
      const cbToss = (commentaryList||[]).find(c => (c.delivery_type||'').toLowerCase() === 'toss' && (c.commentary||'').trim());
      let text = null;
      if (cbToss && cbToss.commentary && !/^toss not available$/i.test(String(cbToss.commentary).trim())) {
        text = cbToss.commentary;
      } else if (normalized && normalized.winner_team_id) {
        const winnerName = names[String(normalized.winner_team_id)] || normalized.winner_team_id;
        const decisionText = (normalized.decision||'').toLowerCase() === 'bowl' || (normalized.decision||'').toLowerCase() === 'field' ? 'bowl first' : 'bat first';
        text = `üé≤ ${winnerName} won the toss and chose to ${decisionText}.`;
      } else if (normalized && normalized.text) {
        text = normalized.text;
        if (!/üé≤/.test(text)) text = `üé≤ ${text}`;
      } else {
        text = null;
      }
      const bannerHtml = text ? `<div class="toss-line"><div class="toss-banner">${text}</div></div>` : "";
      if (tossBannerInline) tossBannerInline.innerHTML = bannerHtml;
      if (tossBannerScore) tossBannerScore.innerHTML = bannerHtml;
    }

    /* battingFirst/battingSecond mapping (important for correct labels) */
    let battingFirst = null;
    let battingSecond = null;

    /* playback helpers */
    function setButtons(){
      const done = shown >= balls.length;
      btnPlay.disabled = timer !== null || done;
      btnPause.disabled = timer === null;
      btnNext.disabled = done;
      btnOver.disabled = done;
      btnRestart.disabled = shown === 0 && !done;
    }
    function play(){ if(timer || shown >= balls.length) return; timer = setInterval(()=>{ if(!stepOne()) pause(); }, delay); setButtons(); }
    function pause(){ if(timer) clearInterval(timer); timer = null; setButtons(); }
    function restart(){ pause(); shown = 0; commFeed.innerHTML = ""; updateMini([]); setButtons(); liveBatRuns.clear(); }
    speedSel.onchange = ()=>{ delay = parseInt(speedSel.value,10) || 700; if(timer){ pause(); play(); } };
    btnPlay.onclick = ()=> play();
    btnPause.onclick = ()=> pause();
    btnNext.onclick = ()=> { stepOne(); setButtons(); };
    btnOver.onclick = ()=> { stepOver(); setButtons(); };
    btnRestart.onclick = ()=> restart();

    /* actual step / replay logic */
    function stepOne(){
      if (shown >= balls.length) { maybeFinalMessage(); return false; }
      const b = balls[shown++];

      const extras = [];
      const prev = balls[shown-2] || null;
      const overStart = !prev || prev.innings !== b.innings || prev.over_number !== b.over_number;
      if (overStart && prev) {
        const bow = nameWithBadges(b.bowler_id);
        extras.push(`${bow} comes into the attack.`);
      }
      const dt = (b.delivery_type||"legal").toLowerCase();
      if (dt === "wide") extras.push(`Wide ‚Äî +${b.extras||1}`);
      if (dt === "noball") extras.push(`No-ball ‚Äî +${b.extras||1}`);
      if (dt === "bye" && (b.extras_detail?.byes)) extras.push(`Byes ‚Äî +${b.extras_detail.byes}`);

      const prevRuns = liveBatRuns.get(b.striker_id) || 0;
      const newRuns = prevRuns + (b.runs_scored || 0);
      liveBatRuns.set(b.striker_id, newRuns);
      if (newRuns >= 50 && prevRuns < 50 && newRuns < 100) extras.push(`${nameWithBadges(b.striker_id)} scores his FIFTY`);
      else if (newRuns >= 100 && prevRuns < 100) extras.push(`${nameWithBadges(b.striker_id)} scores his HUNDRED`);

      if (b.wicket) {
        const t = (b.dismissal_type||"").toLowerCase();
        const bow = nameWithBadges(b.bowler_id);
        const fld = b.fielder_id ? nameWithBadges(b.fielder_id) : "";
        let disTxt = "out";
        if (t === "bowled") disTxt = `b ${bow}`;
        else if (t === "lbw") disTxt = `lbw b ${bow}`;
        else if (t === "caught") {
          if (b.fielder_id && b.bowler_id && b.fielder_id === b.bowler_id) disTxt = `c & b ${bow}`;
          else if (b.fielder_id) disTxt = `c ${fld} b ${bow}`;
          else disTxt = `c b ${bow}`;
        } else if (t === "runout" || t === "run-out") disTxt = b.fielder_id ? `run out (${fld})` : `run out`;
        const outPid = b.dismissed_batsman_id || b.striker_id;
        const faced = balls.slice(0, shown).filter(x=>x.innings===b.innings && x.striker_id===outPid && isLegal(x)).length;
        const runs = liveBatRuns.get(outPid) || 0;
        extras.push(`${nameWithBadges(outPid)} ${disTxt} ${runs}(${faced})`);
        const nextBall = balls[shown] || null;
        if (nextBall && nextBall.innings === b.innings) {
          const newcomer = nextBall.striker_id !== outPid && nextBall.striker_id !== (prev?.striker_id) ? nextBall.striker_id : nextBall.non_striker_id;
          if (newcomer) extras.push(`${nameWithBadges(newcomer)} comes in to the Crease.`);
        }
      }

      commFeed.insertAdjacentHTML("afterbegin", ballHtml(b, extras));
      updateMini(balls.slice(0, shown));

      // End of innings message
      const next = balls[shown] || null;
      if (!next || next.innings !== b.innings) {
        if (b.innings === 1) {
          const t1 = totals(balls,1);
          const need = t1.runs + 1;
          const ballsLeft = 120;
          const chasingName = names[battingSecond] || names[fixture.away_team_id] || "Team B";
          commFeed.insertAdjacentHTML("afterbegin",
            `<div class="ball"><div class="head">End of Innings 1</div><div>${chasingName} required ${need} runs from ${ballsLeft} balls to win</div></div>`);
        }
      }

      if (shown >= balls.length) { maybeFinalMessage(); return false; }
      return true;
    }

    function stepOver(){
      if (shown >= balls.length) { maybeFinalMessage(); return; }
      const curr = balls[shown]; if (!curr) return;
      const tgtInn = curr.innings, tgtOver = curr.over_number + 1;
      while (shown < balls.length){
        const b = balls[shown];
        if (!stepOne()) break;
        if (b.innings === tgtInn && b.over_number === tgtOver) break;
      }
    }

    function maybeFinalMessage(){
      const t1 = totals(balls,1), t2 = totals(balls,2);
      let winnerText = "";
      const homeName = names[fixture.home_team_id] || "Home";
      const awayName = names[fixture.away_team_id] || "Away";

      if (fixture && fixture.winner_team_id) {
        winnerText = `${names[fixture.winner_team_id] || fixture.winner_team_id} won the match`;
      } else {
        if (t1.runs > t2.runs) {
          const teamName = names[battingFirst] || homeName;
          const margin = t1.runs - t2.runs;
          winnerText = `${teamName} won the match by ${margin} runs`;
        } else if (t2.runs > t1.runs) {
          const teamName = names[battingSecond] || awayName;
          const wktsLeft = 10 - t2.wkts;
          winnerText = `${teamName} won the match by ${wktsLeft} wickets`;
        } else {
          winnerText = "Match tied";
        }
      }

      commFeed.insertAdjacentHTML("afterbegin", `<div class="ball"><div class="head">END of the MATCH</div><div>${winnerText}</div></div>`);
      setButtons();
    }

    /* load data and render */
    function formatDateTime(ts){
      if(!ts) return "--";
      const d = new Date(ts);
      const dd = String(d.getDate()).padStart(2,"0");
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const yyyy = d.getFullYear();
      const h24 = d.getHours();
      const hh = String(h24 % 12 || 12).padStart(2,"0");
      const mi = String(d.getMinutes()).padStart(2,"0");
      const ampm = h24 >= 12 ? "PM" : "AM";
      return `${dd}-${mm}-${yyyy}, ${hh}:${mi} ${ampm}`;
    }

    async function loadReplay(){
      if (!fixtureId) { alert("Missing fixture id"); return; }

      const { data: fx } = await supabase.from("fixtures").select("*").eq("id", fixtureId).maybeSingle();
      if (!fx) { alert("Fixture not found"); return; }
      fixture = fx;

      // teams
      const teamIds = [fx.home_team_id, fx.away_team_id].filter(Boolean);
      if (teamIds.length) {
        const { data: teams } = await supabase.from("teams").select("id,team_name").in("id", teamIds);
        (teams||[]).forEach(t=> names[t.id] = t.team_name);
      }

      // players for both teams
      const { data: ps } = await supabase.from("players").select("id,name,team_id,batting,bowling").in("team_id", [fx.home_team_id, fx.away_team_id]);
      (ps||[]).forEach(p=> players[p.id] = { name: p.name, team_id: p.team_id, batting: p.batting, bowling: p.bowling });

      // compute battingFirst/battingSecond robustly
      const normalized = normalizeTossFromPayload(fx);
      if (normalized && normalized.winner_team_id) {
        const winner = String(normalized.winner_team_id);
        const decision = (normalized.decision || '').toLowerCase();
        const home = String(fx.home_team_id), away = String(fx.away_team_id);
        if (decision === 'bowl' || decision === 'field') {
          if (winner === home) { battingFirst = fx.away_team_id; battingSecond = fx.home_team_id; }
          else { battingFirst = fx.home_team_id; battingSecond = fx.away_team_id; }
        } else {
          if (winner === home) { battingFirst = fx.home_team_id; battingSecond = fx.away_team_id; }
          else { battingFirst = fx.away_team_id; battingSecond = fx.home_team_id; }
        }
      } else if (Array.isArray(fx.innings) && fx.innings.length >= 2 && fx.innings[0].team_id) {
        battingFirst = fx.innings[0].team_id; battingSecond = fx.innings[1].team_id;
      } else {
        battingFirst = fx.home_team_id; battingSecond = fx.away_team_id;
      }

      // load ball_by_ball_league_s1 for fixture
      const { data: bdata } = await supabase
        .from("ball_by_ball_league_s1")
        .select("*")
        .eq("fixture_id", fixtureId)
        .order("innings", { ascending: true })
        .order("over_number", { ascending: true })
        .order("ball_in_over", { ascending: true })
        .order("created_at", { ascending: true });

      let fetched = (bdata || []).slice();

      // ensure toss row present client-side and remove early noisy lines
      // if toss missing, insert synthetic toss into array (not database) for display
      const hasToss = fetched.some(c => (c.delivery_type||'').toLowerCase() === 'toss');
      if (!hasToss) {
        const normalizedT = normalizeTossFromPayload(fx);
        let comment = 'Toss not available';
        if (normalizedT && normalizedT.winner_team_id) {
          const winnerName = names[normalizedT.winner_team_id] || `Team ${String(normalizedT.winner_team_id).slice(0,8)}`;
          comment = `Toss: ${winnerName} won the toss and elected to ${normalizedT.decision || 'bat'}.`;
        } else if (fx.result && fx.result.toss && fx.result.toss.text) {
          comment = fx.result.toss.text;
        }
        const tossRow = {
          fixture_id: fixtureId,
          over_number: 0,
          ball_in_over: 0,
          innings: 0,
          striker_id: null,
          non_striker_id: null,
          bowler_id: null,
          runs_scored: 0,
          extras: 0,
          wicket: false,
          dismissal_type: null,
          dismissed_batsman_id: null,
          commentary: comment,
          created_at: new Date(Date.now()-1000).toISOString(),
          fielder_id: null,
          delivery_type: 'toss',
          extras_detail: {}
        };
        fetched.unshift(tossRow);
      }

      // filter initial noisy "comes into the attack" lines if before first real ball
      const firstRealIdx = fetched.findIndex(c => {
        const dt = (c.delivery_type||'').toLowerCase();
        if (dt === 'toss') return false;
        if (['legal','wide','noball','bye'].includes(dt)) return true;
        if (typeof c.over_number === 'number' && c.over_number > 0) return true;
        return false;
      });
      const cutoff = firstRealIdx === -1 ? 3 : firstRealIdx + 1;
      const noiseRegex = /\bcomes into the attack\b/i;
      fetched = fetched.filter((c,i) => { if (i < cutoff && typeof c.commentary === 'string' && noiseRegex.test(c.commentary)) return false; return true; });

      // stable sort: toss first then innings/over/ball/created_at
      balls = fetched.sort((a,b)=>{
        if ((a.delivery_type||'').toLowerCase() === 'toss' && (b.delivery_type||'').toLowerCase() !== 'toss') return -1;
        if ((b.delivery_type||'').toLowerCase() === 'toss' && (a.delivery_type||'').toLowerCase() !== 'toss') return 1;
        if ((a.innings||0) !== (b.innings||0)) return (a.innings||0)-(b.innings||0);
        if ((a.over_number||0) !== (b.over_number||0)) return (a.over_number||0)-(b.over_number||0);
        if ((a.ball_in_over||0) !== (b.ball_in_over||0)) return (a.ball_in_over||0)-(b.ball_in_over||0);
        const ta = new Date(a.created_at||0).getTime();
        const tb = new Date(b.created_at||0).getTime();
        return ta - tb;
      });

      // UI updates
      shown = 0;
      commFeed.innerHTML = "";
      liveBatRuns.clear();

      titleEl.textContent = `${names[fx.home_team_id] || "Home"} vs ${names[fx.away_team_id] || "Away"}`;
      const when = fx.kickoff_at || (fx.date && fx.start_time ? `${fx.date}T${fx.start_time}` : null);
      replayDate.textContent = when ? formatDateTime(when) : "--";
      subEl.textContent = `Kickoff ‚Äî ${when?formatDateTime(when):"--"}`;
      statusChip.textContent = fx.status || "--";

      // Score aggregates
      const t1 = totals(balls,1), t2 = totals(balls,2);
      headlineA.textContent = `${names[battingFirst] || 'Team A'} ${t1.runs}/${t1.wkts} (${oversTxt(t1.legal)} ov)`;
      headlineB.textContent = `${names[battingSecond] || 'Team B'} ${t2.runs}/${t2.wkts} (${oversTxt(t2.legal)} ov)`;

      in1Name.textContent = `${names[battingFirst] || 'Team A'} ‚Äî Innings 1`;
      in2Name.textContent = `${names[battingSecond] || 'Team B'} ‚Äî Innings 2`;
      in1Tot.textContent = `${t1.runs}/${t1.wkts} in ${oversTxt(t1.legal)} ov`;
      in2Tot.textContent = `${t2.runs}/${t2.wkts} in ${oversTxt(t2.legal)} ov`;

      const batAgg1 = aggBat(balls,1), batAgg2 = aggBat(balls,2);
      const dm1 = dismissalMap(balls,1), dm2 = dismissalMap(balls,2);
      rowBat(bat1, batAgg1, dm1); rowBat(bat2, batAgg2, dm2);

      const bowlAgg1 = aggBowl(balls,1), bowlAgg2 = aggBowl(balls,2);
      rowBowl(bowl1, bowlAgg1); rowBowl(bowl2, bowlAgg2);

      updateMini(balls);

      // toss banner
      renderTossBanner(fx, balls);

      // summary panel
      const homeName = names[fx.home_team_id] || 'Home';
      const awayName = names[fx.away_team_id] || 'Away';
      const homeRuns = (fx.result && fx.result.home && typeof fx.result.home.runs !== 'undefined') ? fx.result.home.runs : t1.runs;
      const awayRuns = (fx.result && fx.result.away && typeof fx.result.away.runs !== 'undefined') ? fx.result.away.runs : t2.runs;

      let winnerLabel = null;
      if (fx.winner_team_id) winnerLabel = names[fx.winner_team_id] || String(fx.winner_team_id);
      else if (fx.result && fx.result.winner) {
        const rw = fx.result.winner;
        if (rw === 'home') winnerLabel = homeName;
        else if (rw === 'away') winnerLabel = awayName;
        else winnerLabel = names[rw] || rw;
      } else {
        if (t1.runs > t2.runs) winnerLabel = names[battingFirst] || homeName;
        else if (t2.runs > t1.runs) winnerLabel = names[battingSecond] || awayName;
        else winnerLabel = null;
      }

      if (!winnerLabel) resultLine.textContent = `Match tied ‚Äî ${homeName} ${homeRuns}, ${awayName} ${awayRuns}`;
      else resultLine.textContent = `${winnerLabel} won the match`;

      sumHomeName.textContent = homeName; sumAwayName.textContent = awayName;
      sumHomeScore.textContent = `${homeRuns} (${oversTxt(t1.legal)} ov)`;
      sumAwayScore.textContent = `${awayRuns} (${oversTxt(t2.legal)} ov)`;

      const tbHome = topBattersFor(fx.home_team_id, [batAgg1, batAgg2]);
      const tbAway = topBattersFor(fx.away_team_id, [batAgg1, batAgg2]);
      const bwHome = topBowlersFor(fx.home_team_id, [bowlAgg1, bowlAgg2]);
      const bwAway = topBowlersFor(fx.away_team_id, [bowlAgg1, bowlAgg2]);

      fillList(sumHomeTopBat, tbHome); fillList(sumAwayTopBat, tbAway);
      fillList(sumHomeTopBowl, bwHome); fillList(sumAwayTopBowl, bwAway);

      setButtons();
    }

    function fillList(ul, items){ ul.innerHTML = ""; items.forEach(i=> ul.insertAdjacentHTML("beforeend", `<li>${i}</li>`)); }

    function topBattersFor(teamId, maps){
      const comb = {};
      for (const map of maps){
        for (const [pid, st] of Object.entries(map)){
          const c = comb[pid] ||= { r:0, b:0 };
          c.r += st.r; c.b += st.b;
        }
      }
      return Object.entries(comb)
        .filter(([pid]) => players[pid] && players[pid].team_id === teamId)
        .map(([pid,st]) => ({ pid, r: st.r, b: st.b, sr: st.b ? st.r/st.b*100 : 0 }))
        .sort((a,b)=> b.r - a.r || b.sr - a.sr)
        .slice(0,3)
        .map(x => `${nameWithBadges(x.pid)} ‚Äî ${x.r} (${x.b}), SR ${x.sr.toFixed(1)}`);
    }
    function topBowlersFor(teamId, maps){
      const comb = {};
      for (const map of maps){
        for (const [pid, st] of Object.entries(map)){
          const c = comb[pid] ||= { r:0, b:0, w:0 };
          c.r += st.r; c.b += st.b; c.w += st.w;
        }
      }
      return Object.entries(comb)
        .filter(([pid]) => players[pid] && players[pid].team_id === teamId)
        .map(([pid,st]) => ({ pid, w: st.w, eco: st.b ? st.r/(st.b/6) : 0 }))
        .sort((a,b)=> b.w - a.w || a.eco - b.eco)
        .slice(0,3)
        .map(x => `${nameWithBadges(x.pid)} ‚Äî ${x.w} wkts, ${x.eco.toFixed(1)} econ`);
    }

    // init
    loadReplay();

  </script>
</body>
</html>
