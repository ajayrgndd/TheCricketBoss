<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Home ‚Äì TheCricketBoss</title>
  <link rel="stylesheet" href="styles/global.css" />
  <style>
    body { background-color:#121212; color:#fff; font-family:sans-serif; margin:0; padding-bottom:80px; }
    .main { padding:20px; padding-top:80px; max-width:800px; margin:auto; }
    h2,h3 { text-align:center; margin-bottom:20px; }
    button { padding:12px 24px; font-size:16px; background:#00e676; color:black; border:none; border-radius:6px; cursor:pointer; margin-top:10px; }
    button:disabled { background:gray; cursor:not-allowed; }
    .grid-container { display:grid; grid-template-columns:1fr; gap:20px; }
    .grid-item { background-color:#1e1e1e; padding:16px; border-radius:10px; box-shadow:0 2px 5px rgba(0,0,0,0.3); }
    /* XP */
    .xp-bar-container { margin:12px 0 20px; position:relative; text-align:center; }
    .xp-bar-top { display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; font-size:13px; color:#cfd3ff; padding:0 4px; }
    .xp-level-left,.xp-level-right { font-weight:800; color:#fff; font-size:13px; }
    .xp-bar { width:100%; height:18px; background:#333; border-radius:10px; overflow:hidden; margin-bottom:6px; }
    .xp-fill { height:100%; width:0%; transition:width .4s ease; background: linear-gradient(90deg,#7c4dff 0%,#536dfe 30%,#00e676 60%,#ffd54f 100%); }
    .xp-count { font-size:0.85rem; color:#ccc; }
    /* Next match */
    .match-card { display:flex; gap:10px; align-items:center; }
    .team-block { display:flex; gap:8px; align-items:center; }
    .team-logo { width:44px; height:44px; border-radius:8px; object-fit:cover; background:#222; border:1px solid rgba(255,255,255,0.04); }
    .team-text { display:flex; flex-direction:column; gap:3px; }
    .team-name { font-weight:700; font-size:14px; color:#fff; }
    .ovr-row { font-size:12px; color:#cfd3ff; display:flex; align-items:center; gap:6px; }
    .match-meta { margin-left:10px; color:#cfd3ff; text-align:center; }
    .badge { font-size:11px; padding:4px 7px; border-radius:8px; background:#222; color:#cfd3ff; border:1px solid rgba(255,255,255,0.04); display:inline-block; }
    .kickoff { margin-top:6px; font-weight:700; font-size:13px; }
    .countdown { font-weight:700; font-size:13px; color:#00e676; margin-top:6px; }
    /* Prep */
    .prep { display:flex; flex-direction:column; gap:6px; }
    .prep-bar { height:8px; background:#2b2b2b; border-radius:6px; overflow:hidden; }
    .prep-fill { height:100%; background: linear-gradient(90deg, #FFD54F 0%, #C8E6C9 35%, #FFB74D 70%, #FF5252 100%); width:0%; transition:width .45s ease; }
    .prep-percent { font-weight:800; color:#cfd3ff; font-size:12px; }
    .prep-tasks { display:flex; flex-direction:column; gap:6px; margin-top:6px; }
    .task { display:flex; align-items:center; gap:8px; color:#cfd3ff; font-size:12px; }
    .task .dot { width:12px; height:12px; border-radius:50%; display:inline-block; text-align:center; line-height:12px; font-weight:800; font-size:11px; }
    .task.done .dot { background:#00e676; color:#000; }
    .task.pending .dot { background:#444; color:#999; }
    .task .txt { flex:1; }
    .task a { color:#00e676; text-decoration:none; font-weight:700; font-size:11px; }
    /* Top 3 */
    .top-player-name { font-size:13px; font-weight:700; color:#fff; }
    .top-player-role { font-size:12px; color:#cfd3ff; }
    .top-player-skill { font-size:12px; color:#a8f5c6; display:flex; align-items:center; gap:8px; justify-content:center; }
    @media (max-width:520px){ .match-card { flex-direction:column; align-items:flex-start } .match-meta { margin-left:0; text-align:left; } }
  </style>
</head>
<body>

  <!-- Top bar & bottom nav injected by shared-ui.js -->

  <div class="main">
    <!-- XP bar -->
    <div class="xp-bar-container">
      <div class="xp-bar-top">
        <div id="level-current" class="xp-level-left">Level: Beginner</div>
        <div id="level-next" class="xp-level-right">Next: Expert</div>
      </div>
      <div class="xp-bar"><div id="xp-fill" class="xp-fill"></div></div>
      <div id="xp-label" class="xp-count">XP: 0 / 500</div>
    </div>

    <div class="grid-container">
      <div class="grid-item" id="fixture-block">
        <h3>Next Match</h3>
        <div id="fixture-info">Loading...</div>
      </div>

      <div class="grid-item">
        <h3>Match Preparation</h3>
        <div id="prepBlock" class="prep">
          <div class="prep-bar"><div id="prepFill" class="prep-fill"></div></div>
          <div id="prepPercent" class="prep-percent">0%</div>
          <div class="prep-tasks" id="prepTasks">
            <div class="task pending" data-task="training"><div class="dot">‚Äì</div><div class="txt">Training: <strong id="t-training">Pending</strong></div><a href="training.html">Go</a></div>
            <div class="task pending" data-task="scout"><div class="dot">‚Äì</div><div class="txt">Scout (Wed): <strong id="t-scout">Pending</strong></div><a href="scout.html">Go</a></div>
            <div class="task pending" data-task="lineup"><div class="dot">‚Äì</div><div class="txt">Default Lineup: <strong id="t-lineup">Pending</strong></div><a href="set-lineup.html">Go</a></div>
            <div class="task pending" data-task="fitness"><div class="dot">‚Äì</div><div class="txt">Average Fitness > 95: <strong id="t-fitness">Pending</strong></div><a href="team.html">Fix</a></div>
          </div>
        </div>
      </div>

      <div class="grid-item">
        <h3>Top 3 Players</h3>
        <div id="top-players-list" class="quick-grid" style="text-align:center;"></div>
      </div>
    </div>

    <div class="quick-links">
      <div class="quick-grid">
        <a href="league.html"><div class="icon">üèÜ</div><div class="label">League</div></a>
        <a href="team.html"><div class="icon">üßç‚Äç‚ôÇÔ∏è</div><div class="label">My Team</div></a>
        <a href="matches.html"><div class="icon">üìä</div><div class="label">Matches</div></a>
        <a href="training.html"><div class="icon">üß†</div><div class="label">Training</div></a>
        <a href="scout.html"><div class="icon">üïµÔ∏è‚Äç‚ôÇÔ∏è</div><div class="label">Scout</div></a>
        <a href="academy.html"><div class="icon">üéì</div><div class="label">Academy</div></a>
        <a href="book-friendly.html"><div class="icon">ü§ù</div><div class="label">Friendly</div></a>
        <a href="stadium.html"><div class="icon">üèüÔ∏è</div><div class="label">Stadium</div></a>
        <a href="store.html"><div class="icon">üõí</div><div class="label">Store</div></a>
        <a href="finance.html"><div class="icon">üí∞</div><div class="label">Finance</div></a>
        <a href="halloffame.html"><div class="icon">üëë</div><div class="label">Hall of Fame</div></a>
        <a href="myprofile.html"><div class="icon">‚öôÔ∏è</div><div class="label">Profile</div></a>
      </div>
    </div>
  </div>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";
    import { loadSharedUI, addManagerXP } from "./js/shared-ui.js";

    const supabase = createClient(
      "https://iukofcmatlfhfwcechdq.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml1a29mY21hdGxmaGZ3Y2VjaGRxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM0NTczODQsImV4cCI6MjA2OTAzMzM4NH0.XMiE0OuLOQTlYnQoPSxwxjT3qYKzINnG6xq8f8Tb_IE"
    );

    const toNum = v => (v == null || v === '') ? 0 : Number(v);

    function shortName(full) {
      if (!full) return '‚Äì';
      const parts = String(full).trim().split(/\s+/).filter(Boolean);
      if (parts.length === 0) return '‚Äì';
      if (parts.length === 1) return parts[0];
      const last = parts[parts.length - 1];
      const initials = parts.slice(0, parts.length - 1).map(p => p[0].toUpperCase()).join(' ');
      return `${initials} ${last}`;
    }

    function fmtOne(val) {
      if (Number.isNaN(val)) return "‚Äì";
      return (Math.round(val * 10) / 10).toFixed(1);
    }

    // ---------- training window helpers ----------
    function toIST(date = new Date()) {
      const utc = new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
      return new Date(utc.getTime() + (5.5 * 3600 * 1000));
    }
    function formatYYYYMMDDIST(d) {
      const y = d.getFullYear(); const m = String(d.getMonth()+1).padStart(2,'0'); const dd = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${dd}`;
    }
    // decide previous training window (name + week_anchor)
    function prevTrainingWindow(reference = new Date()) {
      const ist = toIST(reference);
      const day = ist.getDay();
      const offsetToMon = (day + 6) % 7;
      const thisMonday = new Date(ist); thisMonday.setDate(ist.getDate() - offsetToMon); thisMonday.setHours(0,0,0,0);

      const mon19 = new Date(thisMonday); mon19.setHours(19,0,0,0);
      const mon22 = new Date(thisMonday); mon22.setHours(22,0,0,0);
      const thu = new Date(thisMonday); thu.setDate(thisMonday.getDate() + 3);
      const thu19 = new Date(thu); thu19.setHours(19,0,0,0);
      const thu22 = new Date(thu); thu22.setHours(22,0,0,0);
      const nextMon = new Date(thisMonday); nextMon.setDate(thisMonday.getDate() + 7);
      const nextMon19 = new Date(nextMon); nextMon19.setHours(19,0,0,0);

      let prevWindow, prevWeekAnchorDate;
      if (ist >= mon22 && ist < thu19) {
        // in mon-window -> previous was thu-window (previous week)
        prevWindow = 'thu';
        prevWeekAnchorDate = new Date(thisMonday); prevWeekAnchorDate.setDate(thisMonday.getDate() - 7);
      } else if (ist >= thu22 && ist < nextMon19) {
        // in thu-window -> previous was mon-window (this week)
        prevWindow = 'mon';
        prevWeekAnchorDate = thisMonday;
      } else if (ist >= thu19 && ist < thu22) {
        prevWindow = 'mon';
        prevWeekAnchorDate = thisMonday;
      } else if (ist >= mon19 && ist < mon22) {
        prevWindow = 'thu';
        prevWeekAnchorDate = new Date(thisMonday); prevWeekAnchorDate.setDate(thisMonday.getDate() - 7);
      } else {
        prevWindow = 'thu';
        prevWeekAnchorDate = new Date(thisMonday); prevWeekAnchorDate.setDate(thisMonday.getDate() - 7);
      }
      return { window: prevWindow, week_anchor: formatYYYYMMDDIST(prevWeekAnchorDate) };
    }

    // primary check: profiles.last_training_window_anchor + which
    // fallback: query training_sessions table for the previous window
    async function trainingCompletedForPreviousWindow(supabaseClient, userProfile, userId) {
      // if profile has last_training_window_* we can trust it (fast)
      if (userProfile?.last_training_window_anchor && userProfile?.last_training_window_which) {
        const prev = prevTrainingWindow(new Date());
        // profile stores date as YYYY-MM-DD (your sample shows that)
        if (String(userProfile.last_training_window_anchor) === String(prev.week_anchor)
            && String(userProfile.last_training_window_which) === String(prev.window)) {
          return true;
        }
      }
      // fallback to checking training_sessions rows for previous window
      const prev = prevTrainingWindow(new Date());
      try {
        const { data, error } = await supabaseClient
          .from('training_sessions')
          .select('id')
          .eq('user_id', userId)
          .eq('window', prev.window)
          .eq('week_anchor', prev.week_anchor)
          .limit(1);
        if (error) {
          console.warn('training_sessions query error', error);
          return false;
        }
        return (data && data.length > 0);
      } catch (e) {
        console.warn('training_sessions query failed', e);
        return false;
      }
    }

    // ---------- other helpers (matches, picks, ratings) ----------
    function parseKickoff(m) {
      if (!m) return null;
      if (m.kickoff_at) return new Date(m.kickoff_at);
      if (m.started_at) return new Date(m.started_at);
      try {
        const date = m.date;
        const t = m.start_time || '21:00:00';
        if (!date) return null;
        const [y,mo,da] = (typeof date === 'string' ? date.split('T')[0] : new Date(date).toISOString().split('T')[0]).split('-').map(Number);
        const [hh,mm,ss] = (t + ':00').split(':').map(Number);
        const dt = new Date(); dt.setFullYear(y, mo-1, da); dt.setHours(hh, mm||0, ss||0,0);
        return dt;
      } catch (e) { return null; }
    }
    function humanKickoff(dt) {
      if (!dt) return 'TBA';
      try {
        const opts = { weekday:'short', month:'short', day:'numeric', hour:'numeric', minute:'2-digit', hour12:true, timeZone:'Asia/Kolkata' };
        return dt.toLocaleString('en-IN', opts) + ' IST';
      } catch (e) { return dt.toString(); }
    }
    function formatCountdown(ms) {
      if (ms <= 0) return 'LIVE';
      const sec = Math.floor(ms/1000);
      const d = Math.floor(sec/86400);
      const h = Math.floor((sec%86400)/3600);
      const m = Math.floor((sec%3600)/60);
      const s = sec%60;
      if (d>0) return `${d}d ${h}h`;
      if (h>0) return `${h}h ${m}m`;
      return `${m}m ${s}s`;
    }

    function pickByLineupOrAuto(allPlayers, lineup) {
      const byId = new Map((allPlayers || []).map(p => [p.id,p]));
      let xi = [];
      if (lineup && Array.isArray(lineup.playing_xi) && lineup.playing_xi.length) {
        xi = lineup.playing_xi.map(id => byId.get(id)).filter(Boolean);
      } else {
        const sorted = [...(allPlayers || [])].sort((a,b) => (toNum(b.batting)+toNum(b.bowling)+toNum(b.keeping)) - (toNum(a.batting)+toNum(a.bowling)+toNum(a.keeping)));
        xi = sorted.slice(0, Math.min(11, sorted.length));
      }
      const sortBy = (arr,key) => [...arr].sort((a,b)=>toNum(b[key]) - toNum(a[key]));
      let wk = null;
      if (lineup && lineup.keeper) wk = byId.get(lineup.keeper) || null;
      if (!wk) wk = sortBy(xi.length?xi:allPlayers,'keeping')[0] || null;
      const poolForAR = (xi.length?xi:allPlayers).filter(p=>!wk||p.id!==wk.id);
      let ar = null;
      if (poolForAR.length) ar = [...poolForAR].sort((a,b)=>(toNum(b.batting)+toNum(b.bowling))-(toNum(a.batting)+toNum(a.bowling)))[0];
      const batters = sortBy(xi.length?xi:allPlayers,'batting').filter(p=>!wk||p.id!==wk.id).slice(0,4);
      const bowlers = sortBy(xi.length?xi:allPlayers,'bowling').filter(p=>(!wk||p.id!==wk.id)&&(!ar||p.id!==ar.id)).slice(0,5);
      return { xi, wk, ar, batters, bowlers };
    }
    function computeRatings({ xi, wk, ar, batters, bowlers }) {
      const batSum = batters.reduce((s,p)=>s+toNum(p.batting),0) + (wk?toNum(wk.batting):0) + (ar?toNum(ar.batting):0);
      const batAvg = (batters.length + (wk?1:0) + (ar?1:0)) ? batSum/6 : 0;
      const ballSum = bowlers.reduce((s,p)=>s+toNum(p.bowling),0) + (ar?toNum(ar.bowling):0);
      const ballAvg = (bowlers.length + (ar?1:0)) ? ballSum/6 : 0;
      const wkVal = wk ? toNum(wk.keeping) : 0;
      let ovr = 0;
      if (xi && xi.length) {
        const per = xi.map(p => (toNum(p.batting)+toNum(p.bowling)+toNum(p.keeping))/3);
        ovr = per.reduce((s,v)=>s+v,0) / xi.length;
      }
      return { bat:batAvg, ball:ballAvg, wk:wkVal, ovr:(batAvg + ballAvg + wkVal)/3, ovrXI:ovr };
    }

    // ------------------- main -------------------
    async function main(){
      const { data:{ user } } = await supabase.auth.getUser();
      if (!user) return location.href = "login.html";

      // profile and team first
      const [{ data: profile }, { data: team }] = await Promise.all([
        supabase.from('profiles').select('*').eq('user_id', user.id).maybeSingle(),
        supabase.from('teams').select('*').eq('owner_id', user.id).maybeSingle()
      ]);
      const prof = profile || null;
      if (!prof?.manager_name || !prof?.team_name) return location.href = "profile-setup.html";
      if (!team || !team[0] && !team) { /* handle maybeSingle returning array in some env */ }
      const teamRow = team?.length ? team[0] : team;

      loadSharedUI({ supabase, manager_name: prof.manager_name, xp: prof.xp ?? 0, coins: prof.coins ?? 0, cash: prof.cash ?? 0 });
      await distributeDailyLoginXP(user.id);

      // XP UI
      const xp = prof.xp ?? 0;
      const levels = [{name:"Beginner",xp:0},{name:"Expert",xp:250},{name:"Professional",xp:750},{name:"Master",xp:1750},{name:"Supreme",xp:3500},{name:"World Class",xp:5500},{name:"Ultimate",xp:8500},{name:"Titan",xp:13500},{name:"The Boss",xp:1500000}];
      let currentLevel = levels[0], nextLevel = levels[1];
      for (let i=0;i<levels.length-1;i++){
        if (xp >= levels[i].xp && xp < levels[i+1].xp){ currentLevel = levels[i]; nextLevel = levels[i+1]; break; }
        else if (xp >= levels[levels.length-1].xp){ currentLevel = levels[levels.length-1]; nextLevel = {name:"MAX", xp: currentLevel.xp+1}; break; }
      }
      const percent = Math.min(((xp - currentLevel.xp) / (nextLevel.xp - currentLevel.xp)) * 100, 100);
      document.getElementById('level-current').textContent = currentLevel.name;
      document.getElementById('level-next').textContent = `Next: ${nextLevel.name}`;
      document.getElementById('xp-label').textContent = `XP: ${xp} / ${nextLevel.xp}`;
      document.getElementById('xp-fill').style.width = `${percent}%`;

      // ensure team exists
      if (!teamRow) { document.getElementById('fixture-info').textContent = 'No team found.'; return; }
      const teamId = teamRow.id;

      // fetch players, lineup
      const [{ data: players }, { data: lineup }] = await Promise.all([
        supabase.from('players').select('*').eq('team_id', teamId),
        supabase.from('lineups').select('playing_xi,keeper,captain,team_id').eq('team_id', teamId).maybeSingle()
      ]);

      // top 3 players (bat/bowl only)
      (function renderTop3(){
        function getSkillTitle(score){
          if (score>100) return "The Boss";
          if (score>80) return "Titan";
          if (score>60) return "World Class";
          if (score>50) return "Supreme";
          if (score>40) return "National";
          if (score>30) return "Professional";
          if (score>20) return "Domestic";
          if (score>10) return "Trainee";
          return "Newbie";
        }
        const all = Array.isArray(players)?players:(players?.data||players||[]);
        const ranked = (all||[]).map(p=>{
          const bat = toNum(p.batting), bowl = toNum(p.bowling);
          const topVal = Math.max(bat,bowl);
          const topSkillName = (bat >= bowl) ? 'Batting' : 'Bowling';
          return {...p, topSkillValue:topVal, topSkillName, topSkillLevel:getSkillTitle(topVal)};
        }).sort((a,b)=>b.topSkillValue - a.topSkillValue).slice(0,3);

        const topEl = document.getElementById('top-players-list');
        const fallback = 'assets/default-avatar.png';
        if (!ranked.length){ topEl.innerHTML = 'No players found.'; return; }
        topEl.innerHTML = `
          <div style="display:flex;justify-content:space-around;align-items:center;">
            ${ranked.map(p=>{
              const icon = (p.topSkillName === 'Batting') ? 'assets/rating/bat.png' : 'assets/rating/ball.png';
              const displayName = shortName(p.name);
              return `
                <div style="text-align:center;max-width:120px;">
                  <img src="${p.image_url || fallback}" alt="${p.name||'Player'}" style="width:60px;height:60px;border-radius:50%;object-fit:cover;object-position:top;margin-bottom:8px;border:2px solid rgba(255,255,255,0.04);" />
                  <div class="top-player-name">${displayName}</div>
                  <div class="top-player-role">${p.role || '‚Äì'}</div>
                  <div class="top-player-skill"><img src="${icon}" style="width:16px;height:16px;vertical-align:middle" /> <span>${p.topSkillLevel}</span></div>
                </div>
              `;
            }).join('')}
          </div>
        `;
      })();

      // fetch upcoming fixtures + friendlies, filter scheduled/running
      const [fixturesRes, friendliesRes] = await Promise.all([
        supabase.from('fixtures').select('*').or(`home_team_id.eq.${teamId},away_team_id.eq.${teamId}`).gte('date', new Date().toISOString().split('T')[0]).order('date',{ascending:true}).limit(5),
        supabase.from('matches').select('*').or(`home_team_id.eq.${teamId},away_team_id.eq.${teamId}`).gte('date', new Date().toISOString().split('T')[0]).order('date',{ascending:true}).limit(5)
      ]);

      const combined = [];
      if (fixturesRes?.data) fixturesRes.data.forEach(f=>combined.push({...f, _kind:'league'}));
      if (friendliesRes?.data) friendliesRes.data.forEach(m=>combined.push({...m, _kind:'friendly'}));
      const allowed = combined.filter(m => m && (m.status === 'scheduled' || m.status === 'running'));

      let nextMatch=null, nextKickoff=null;
      for (const m of allowed) {
        const kd = parseKickoff(m);
        if (!kd) continue;
        if (!nextKickoff || kd < nextKickoff) { nextKickoff = kd; nextMatch = m; }
      }

      const fixtureInfo = document.getElementById('fixture-info');
      const teamCache = new Map();
      async function teamInfo(id) {
        if (!id) return { team_name:'‚Äî', logo_url:null };
        if (teamCache.has(id)) return teamCache.get(id);
        const { data: t } = await supabase.from('teams').select('team_name,logo_url').eq('id', id).single();
        const out = { team_name: t?.team_name ?? '‚Äî', logo_url: t?.logo_url ?? null };
        teamCache.set(id,out);
        return out;
      }

      if (!nextMatch) {
        fixtureInfo.innerHTML = '<div>No upcoming matches</div>';
      } else {
        const homeId = nextMatch.home_team_id, awayId = nextMatch.away_team_id;
        const homeInfo = await teamInfo(homeId), awayInfo = await teamInfo(awayId);
        const opponentId = (homeId === teamId) ? awayId : homeId;

        const ourSelection = pickByLineupOrAuto(players || [], lineup || null);
        const ourRates = computeRatings(ourSelection);

        const oppLineupRes = await supabase.from('lineups').select('playing_xi,keeper,captain').eq('team_id', opponentId).maybeSingle();
        const { data: opponentPlayersData } = await supabase.from('players').select('*').eq('team_id', opponentId);
        const opponentPlayers = opponentPlayersData || [];
        const oppSelection = pickByLineupOrAuto(opponentPlayers || [], oppLineupRes?.data || null);
        const oppRates = computeRatings(oppSelection);

        const kickoffDt = parseKickoff(nextMatch) || new Date();
        fixtureInfo.innerHTML = `
          <div class="match-card">
            <div class="team-block">
              <img class="team-logo" src="${homeInfo.logo_url || 'assets/default-logo.png'}" alt="${homeInfo.team_name}" />
              <div class="team-text">
                <div class="team-name">${homeInfo.team_name}</div>
                <div class="ovr-row"><img src="assets/rating/ovr.png" style="width:16px;height:16px;vertical-align:middle" /> <span>${fmtOne(computeRatings(pickByLineupOrAuto((homeId===teamId?players:opponentPlayers),(homeId===teamId?lineup:oppLineupRes?.data))).ovr)}</span></div>
              </div>
            </div>
            <div class="match-meta">
              <div class="badge">${nextMatch._kind === 'league' ? 'League' : 'Friendly'}</div>
              <div class="kickoff">${humanKickoff(kickoffDt)}</div>
              <div class="countdown" id="matchCountdown">‚Äî</div>
            </div>
            <div class="team-block" style="margin-left:auto">
              <div class="team-text" style="text-align:right">
                <div class="team-name">${awayInfo.team_name}</div>
                <div class="ovr-row" style="justify-content:flex-end"><span>${fmtOne(oppRates.ovr)}</span><img src="assets/rating/ovr.png" style="width:16px;height:16px;vertical-align:middle" /></div>
              </div>
              <img class="team-logo" src="${awayInfo.logo_url || 'assets/default-logo.png'}" alt="${awayInfo.team_name}" />
            </div>
          </div>
        `;
        const countdownEl = document.getElementById('matchCountdown');
        function updateCountdown(){ const now=new Date(); const diff = kickoffDt - now; countdownEl.textContent = formatCountdown(diff); }
        updateCountdown(); setInterval(updateCountdown,1000);
      }

      // ---------------- Preparation tasks ----------------
      // TRAINING: use profile's last_training_window fields first, fallback to training_sessions query
      const trainingDone = await trainingCompletedForPreviousWindow(supabase, prof, user.id);

      // SCOUT: last_scouted_date or last_scouted >= lastWednesday
      function lastWednesday(reference = new Date()) {
        const d = new Date(reference); const day = d.getDay(); const diff = (day >= 3) ? day - 3 : 7 - (3 - day);
        d.setDate(d.getDate() - diff); d.setHours(0,0,0,0); return d;
      }
      const lastWed = lastWednesday(new Date());
      const scoutedDateStr = prof?.last_scouted_date || prof?.last_scouted || null;
      let scoutDone = false;
      if (scoutedDateStr) { const sd = new Date(scoutedDateStr); sd.setHours(0,0,0,0); scoutDone = sd >= lastWed; }

      // LINEUP
      let lineupDone = false;
      try {
        const { data: lu } = await supabase.from('lineups').select('playing_xi,keeper,captain,locked,team_id').eq('team_id', teamId).maybeSingle();
        if (lu?.playing_xi && Array.isArray(lu.playing_xi) && lu.playing_xi.length >= 11) {
          const xiSet = new Set(lu.playing_xi);
          const capOk = !lu.captain || xiSet.has(lu.captain);
          const wkOk = !lu.keeper || xiSet.has(lu.keeper);
          lineupDone = capOk && wkOk;
        } else lineupDone = false;
      } catch (e) { lineupDone = false; }

      // FITNESS (compute avg of XI or auto top 11)
      let useXI = [];
      const luRow = await supabase.from('lineups').select('playing_xi').eq('team_id', teamId).maybeSingle();
      const allPlayers = Array.isArray(players) ? players : (players?.data || players || []);
      if (luRow?.data?.playing_xi && Array.isArray(luRow.data.playing_xi) && luRow.data.playing_xi.length) {
        const idset = new Set(luRow.data.playing_xi);
        useXI = (allPlayers || []).filter(p => idset.has(p.id));
      } else {
        const bats = allPlayers.filter(p => (p.role || '').toLowerCase().includes('bat') || (p.batting && p.batting>0)).sort((a,b)=>toNum(b.batting)-toNum(a.batting)).slice(0,5);
        const ars = allPlayers.filter(p => (p.role||'').toLowerCase().includes('all') || ((p.batting||0)>0 && (p.bowling||0)>0)).sort((a,b)=> (toNum(b.batting)+toNum(b.bowling))-(toNum(a.batting)+toNum(a.bowling))).slice(0,2);
        const bowls = allPlayers.filter(p => (p.role||'').toLowerCase().includes('bowl') || (p.bowling && p.bowling>0)).sort((a,b)=>toNum(b.bowling)-toNum(a.bowling)).slice(0,5);
        const byId = new Map(); [...bats,...ars,...bowls].forEach(p=>{ if (!byId.has(p.id)) byId.set(p.id,p); });
        useXI = Array.from(byId.values()).slice(0,11);
      }
      const fitnessVals = (useXI || []).map(p => toNum(p.fitness));
      const avgFitness = fitnessVals.length ? (fitnessVals.reduce((s,v)=>s+v,0) / fitnessVals.length) : 0;
      const fitnessDone = avgFitness > 95;

      const tasks = [
        { id: 'training', ok: trainingDone, label: trainingDone ? 'Completed' : 'Pending', link: 'training.html' },
        { id: 'scout', ok: scoutDone, label: scoutDone ? 'Completed' : 'Pending', link: 'scout.html' },
        { id: 'lineup', ok: lineupDone, label: lineupDone ? 'Set' : 'Pending', link: 'set-lineup.html' },
        { id: 'fitness', ok: fitnessDone, label: fitnessDone ? `${fmtOne(avgFitness)} avg` : `${fmtOne(avgFitness)} avg`, link: 'team.html' }
      ];
      let score = 0;
      tasks.forEach(t => { if (t.ok) score += 25; const el = document.querySelector(`.task[data-task="${t.id}"]`); if (el){ el.classList.toggle('done', t.ok); el.classList.toggle('pending', !t.ok); const dot = el.querySelector('.dot'); if (dot) dot.textContent = t.ok ? '‚úì' : '!'; const txt = el.querySelector('.txt strong'); if (txt) txt.textContent = t.label; const a = el.querySelector('a'); if (a) a.href = t.link; } });

      document.getElementById('prepFill').style.width = score + '%';
      document.getElementById('prepPercent').textContent = `${score}%`;
      document.getElementById('t-fitness').textContent = fmtOne(avgFitness);

      // periodic refresh (keeps using profile-first approach)
      setInterval(async () => {
        try {
          const newTrainingDone = await trainingCompletedForPreviousWindow(supabase, prof, user.id);
          const { data: pf } = await supabase.from('profiles').select('last_scouted_date,last_scouted').eq('user_id', user.id).single();
          let newScoutDone = false;
          if (pf?.last_scouted_date || pf?.last_scouted) { const sd = new Date(pf.last_scouted_date || pf.last_scouted); sd.setHours(0,0,0,0); newScoutDone = sd >= lastWed; }
          const { data: lu2 } = await supabase.from('lineups').select('playing_xi,keeper,captain').eq('team_id', teamId).maybeSingle();
          const newLineupDone = (lu2?.playing_xi && Array.isArray(lu2.playing_xi) && lu2.playing_xi.length >= 11);
          const { data: playersRef } = await supabase.from('players').select('*').eq('team_id', teamId);
          let newAvg = 0;
          if (lu2?.playing_xi && Array.isArray(lu2.playing_xi) && lu2.playing_xi.length) {
            const idset = new Set(lu2.playing_xi); const use = (playersRef||[]).filter(p=>idset.has(p.id)); newAvg = use.length ? (use.reduce((s,p)=>s+toNum(p.fitness),0)/use.length) : 0;
          } else {
            const all = playersRef || [];
            const bats = all.filter(p => (p.role || '').toLowerCase().includes('bat')).sort((a,b)=>toNum(b.batting)-toNum(a.batting)).slice(0,5);
            const ars = all.filter(p => (p.role||'').toLowerCase().includes('all')).sort((a,b)=> (toNum(b.batting)+toNum(b.bowling))-(toNum(a.batting)+toNum(a.bowling))).slice(0,2);
            const bowls = all.filter(p => (p.role||'').toLowerCase().includes('bowl')).sort((a,b)=>toNum(b.bowling)-toNum(a.bowling)).slice(0,5);
            const byId2 = new Map(); [...bats,...ars,...bowls].forEach(p=>{ if (!byId2.has(p.id)) byId2.set(p.id,p); });
            const use = Array.from(byId2.values()).slice(0,11);
            newAvg = use.length ? (use.reduce((s,p)=>s+toNum(p.fitness),0)/use.length) : 0;
          }
          let newScore = 0; if (newTrainingDone) newScore += 25; if (newScoutDone) newScore += 25; if (newLineupDone) newScore += 25; if (newAvg > 95) newScore += 25;
          document.getElementById('prepFill').style.width = newScore + '%';
          document.getElementById('prepPercent').textContent = `${newScore}%`;
          const map = { training: newTrainingDone, scout: newScoutDone, lineup: newLineupDone, fitness: newAvg > 95 };
          Object.keys(map).forEach(k => {
            const el = document.querySelector(`.task[data-task="${k}"]`); if (!el) return;
            el.classList.toggle('done', map[k]); el.classList.toggle('pending', !map[k]);
            const dot = el.querySelector('.dot'); if (dot) dot.textContent = map[k] ? '‚úì' : '!';
            const txt = el.querySelector('.txt strong'); if (txt) { if (k === 'fitness') txt.textContent = fmtOne(newAvg) + (map[k] ? ' avg' : ' avg'); else txt.textContent = map[k] ? 'Completed' : 'Pending'; }
          });
        } catch (e) { console.warn('Periodic prep refresh failed', e); }
      }, 20000);
    }

    main();
  </script>
</body>
</html>
