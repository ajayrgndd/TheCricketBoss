<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Friendly Match</title>
  <style>
    /* Minimal styling to match your site's dark theme; keep your original styles if you want */
    body { font-family: Inter, system-ui, sans-serif; background:#071019; color:#E6EEF3; margin:0; padding:16px; }
    .container { max-width:980px; margin:0 auto; }
    .header { display:flex; align-items:center; justify-content:space-between; }
    .tabs { margin-top:12px; display:flex; gap:8px; }
    .tab { padding:8px 12px; background:#0d1620; border-radius:6px; cursor:pointer; color:#cfe7ff; }
    .score-strip { margin-top:16px; background:#ff8c1a; color:#071019; padding:12px 16px; border-radius:10px; font-weight:700; display:flex; justify-content:space-between; align-items:center; }
    .toss-banner { margin-top:12px; background:#2d3a66; color:#fff; padding:12px 16px; border-radius:8px; text-align:center; font-weight:600; }
    .teams { margin-top:12px; display:flex; justify-content:space-between; align-items:flex-start; }
    .team { width:48%; background:#0e1720; padding:12px; border-radius:10px; }
    .section-title { font-weight:700; margin-bottom:8px; color:#c2e6c8; }
    .commentary { margin-top:16px; background:#0d1620; padding:12px; border-radius:10px; max-height:420px; overflow:auto; }
    .comment-row { padding:8px 6px; border-bottom:1px solid rgba(255,255,255,0.03); }
    .comment-row.toss { background:rgba(255,255,255,0.02); font-weight:700; color:#fff; }
    .hidden { display:none !important; }
    .muted { color:#9aaec3; font-size:0.95em; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Friendly Match</h1>
      <div>
        <label>Auto refresh <select id="refresh-interval"><option>2s</option><option>5s</option></select></label>
        <button id="btn-refresh">Refresh</button>
      </div>
    </div>

    <div class="tabs" role="tablist" aria-label="Match tabs">
      <div class="tab" data-tab="live" aria-selected="true">LIVE</div>
      <div class="tab" data-tab="scorecard">SCORECARD</div>
      <div class="tab" data-tab="commentary">COMMENTARY</div>
      <div class="tab" data-tab="lineup">LINEUP</div>
    </div>

    <!-- Toss banner must appear above score strip -->
    <div id="toss-banner" class="toss-banner" aria-live="polite">ðŸŽ² Toss not available</div>

    <div class="score-strip" id="score-strip">
      <div id="left-score">--/-- - 0.0 ov</div>
      <div id="right-score">--/-- - 0.0 ov</div>
    </div>

    <div class="teams" id="teams">
      <div class="team" id="home-team">
        <div class="section-title" id="home-team-name">Home Team</div>
        <div class="muted" id="home-team-meta">Batting â€“ home</div>
      </div>
      <div class="team" id="away-team">
        <div class="section-title" id="away-team-name">Away Team</div>
        <div class="muted" id="away-team-meta">Bowling â€“ away</div>
      </div>
    </div>

    <div class="commentary" id="commentary-list" aria-live="polite" role="log">
      <!-- commentary rows will be inserted here -->
      <div class="comment-row muted">Loading commentaryâ€¦</div>
    </div>

  </div>

  <script>
  (function(){
    // === Configuration ===
    // If your page sets a global "MATCH_ID" or "matchId", it will use that. Otherwise it will attempt to read from URL param 'match_id'.
    const MATCH_ID = (window.MATCH_ID || window.matchId || new URLSearchParams(window.location.search).get("match_id") || "").trim();

    // Utility: parse UUID-like strings (loose)
    const UUID_RE = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i;

    // Small helper to pause for debug if needed
    const wait = (ms) => new Promise(r => setTimeout(r, ms));

    // DOM helpers
    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

    // Default API endpoints â€” adjust these to fit your backend if needed
    // These are used only as fallbacks when we cannot resolve names from current DOM.
    const API = {
      match: (id) => `/api/matches/${id}`,
      bbb: (id) => `/api/ball_by_ball?match_id=${id}&order=created_at.asc`,
      team: (id) => `/api/teams/${id}`
    };

    /* =========================================================================
       TOSS + COMMENTARY FIXES
       - replace UUID in toss banner with readable team name
       - ensure toss row is first in commentary (insert if missing)
       - remove "comes into the attack" noise
    ========================================================================= */

    async function getOnPageTeamMapping() {
      // Try to detect team names already present in page (fast)
      // returns { [teamId]: name } for any discovered team id -> name
      const map = {};

      // Common patterns: elements with data-team-id attributes (most robust)
      $$("[data-team-id]").forEach(el => {
        const id = el.getAttribute("data-team-id");
        if (!id) return;
        const name = (el.textContent || "").trim();
        if (name) map[id] = name;
      });

      // If there are specific selectors used in your app, try them
      const homeEl = $("#home-team-name") || $(".team-home") || $(".home .team-name");
      const awayEl = $("#away-team-name") || $(".team-away") || $(".away .team-name");
      if (homeEl && awayEl) {
        // sometimes the page may include data attributes on parent
        const homeParent = homeEl.closest("[data-team-id]");
        const awayParent = awayEl.closest("[data-team-id]");
        if (homeParent) map[homeParent.getAttribute("data-team-id")] = homeEl.textContent.trim();
        if (awayParent) map[awayParent.getAttribute("data-team-id")] = awayEl.textContent.trim();
      }

      // Another heuristic: some apps expose a global match object (match/matchData) â€” check and use it
      try {
        const g = window.match || window.matchData || window.__MATCH__ || window._match;
        if (g && typeof g === "object") {
          if (g.home_team_id && g.home_team_name) map[g.home_team_id] = g.home_team_name;
          if (g.away_team_id && g.away_team_name) map[g.away_team_id] = g.away_team_name;
          // sometimes teams are nested
          if (g.home && g.home.team_id && g.home.team_name) map[g.home.team_id] = g.home.team_name;
          if (g.away && g.away.team_id && g.away.team_name) map[g.away.team_id] = g.away.team_name;
        }
      } catch (e) {
        // ignore
      }

      return map;
    }

    async function fetchTeamNameByApi(id) {
      if (!id) return null;
      try {
        const res = await fetch(API.team(id));
        if (!res.ok) return null;
        const j = await res.json();
        // expect { id, team_name } or { team_name: 'A Team' }
        return j.team_name || j.name || (j.data && j.data.team_name) || null;
      } catch(e) {
        return null;
      }
    }

    async function replaceTossIdsWithNames() {
      const banner = $("#toss-banner");
      if (!banner) return;
      let text = (banner.textContent || "").trim();
      if (!text) return;

      // find first UUID in the text
      const idMatch = text.match(UUID_RE);
      if (!idMatch) return; // nothing to replace

      const id = idMatch[0];
      // try local mapping first
      const map = await getOnPageTeamMapping();

      let name = map[id];
      if (!name) {
        // try fetching from api if configured
        name = await fetchTeamNameByApi(id);
      }
      if (!name) {
        // last fallback: try to locate name by scanning the two team boxes (maybe they contain the id in data-* attr)
        const teamEls = $$("[data-team-id]");
        for (const el of teamEls) {
          if (el.getAttribute("data-team-id") === id) {
            name = (el.textContent || "").trim();
            break;
          }
        }
      }

      if (name) {
        // replace occurrences of the UUID with readable name
        const newText = text.replace(new RegExp(id, "g"), name);
        banner.textContent = newText;
      } else {
        // If we couldn't resolve the name, try to format the UUID into a short form to be more readable
        const short = id.slice(0, 8);
        banner.textContent = text.replace(id, short);
      }
    }

    function removeComesIntoTheAttackNoise() {
      // Find commentary list rows and remove any that are purely "X comes into the attack" or similar
      const container = $("#commentary-list");
      if (!container) return;
      const rows = Array.from(container.children);
      rows.forEach(row => {
        const text = (row.textContent || "").trim();
        if (!text) return;
        // A few likely phrasings we want to quiet:
        if (/comes into the attack/i.test(text) || /comes into the bowling attack/i.test(text) || /comes into the attack\./i.test(text)) {
          // remove the row (but keep a very small visual marker if you want: here we remove entirely)
          row.remove();
        }
      });
    }

    function moveTossRowToTop() {
      // If there's an existing commentary row with data-delivery-type="toss" or class 'toss', move it to top.
      const container = $("#commentary-list");
      if (!container) return;
      // look for explicit data-delivery-type attributes
      let tossRow = container.querySelector('[data-delivery-type="toss"]') || container.querySelector('.comment-row.toss');
      if (tossRow) {
        container.insertBefore(tossRow, container.firstChild);
        return true;
      }
      // alternatively, scan for a row with text "Toss" at start
      const rows = Array.from(container.children);
      for (const r of rows) {
        const txt = (r.textContent || "").trim().toLowerCase();
        if (txt.startsWith("toss") || txt.includes("won the toss") || txt.includes("elected to")) {
          container.insertBefore(r, container.firstChild);
          return true;
        }
      }
      return false;
    }

    function insertVirtualTossRowIfMissing(tossText) {
      const container = $("#commentary-list");
      if (!container) return;
      // if first row is already a toss, nothing to do
      const first = container.firstElementChild;
      if (first && ((first.getAttribute && first.getAttribute("data-delivery-type") === "toss") || (first.classList && first.classList.contains("toss")) || (first.textContent || "").toLowerCase().includes("toss"))) {
        return;
      }
      // create row element and insert at top
      const div = document.createElement("div");
      div.className = "comment-row toss";
      div.setAttribute("data-delivery-type", "toss");
      div.textContent = tossText || "Toss: not available";
      container.insertBefore(div, container.firstChild);
    }

    async function loadCommentaryAndFixes() {
      const container = $("#commentary-list");
      if (!container) return;
      // Clear existing
      container.innerHTML = '<div class="comment-row muted">Loading commentaryâ€¦</div>';

      // Try to load commentary rows from an API endpoint if available (fallback). This is non-destructive: if your page already populated commentary, these steps still run to clean.
      try {
        // Prefer to use existing comment DOM if present (non-API mode):
        const existingRows = $$(".comment-row");
        if (existingRows && existingRows.length > 1) {
          // We already have commentary rows: just run cleanup
          removeComesIntoTheAttackNoise();
          const moved = moveTossRowToTop();
          if (!moved) {
            // try to get toss text from page or match object
            const tossTxt = getExistingTossTextFromPage();
            if (tossTxt) insertVirtualTossRowIfMissing(tossTxt);
          }
          await replaceTossIdsWithNames();
          return;
        }

        // Otherwise attempt to fetch via API (fallback)
        if (!MATCH_ID) {
          container.innerHTML = '<div class="comment-row muted">No match ID available to load commentary.</div>';
          return;
        }
        const res = await fetch(API.bbb(MATCH_ID));
        if (!res.ok) {
          container.innerHTML = `<div class="comment-row muted">Failed to load commentary (HTTP ${res.status}).</div>`;
          return;
        }
        const data = await res.json();
        // Expect array of rows with { delivery_type, commentary, created_at }
        container.innerHTML = "";
        // Ensure toss row first if present in dataset
        const tossRows = data.filter(r => (r.delivery_type || "").toLowerCase() === "toss");
        const otherRows = data.filter(r => (r.delivery_type || "").toLowerCase() !== "toss");
        // If toss row present, push it first; each row -> DOM element
        const pushRow = (r) => {
          const el = document.createElement("div");
          el.className = "comment-row";
          if ((r.delivery_type || "").toLowerCase() === "toss") {
            el.classList.add("toss");
            el.setAttribute("data-delivery-type", "toss");
          } else {
            el.setAttribute("data-delivery-type", r.delivery_type || "legal");
          }
          el.textContent = r.commentary || (r.comment || formatBallRow(r));
          return el;
        };
        if (tossRows.length) {
          container.appendChild(pushRow(tossRows[0]));
        } else {
          // if not present, try to create from match.result / sim_state
          const matchObj = await tryFetchMatchObject(MATCH_ID);
          const tossText = extractTossTextFromMatchObj(matchObj);
          if (tossText) container.appendChild(pushRow({ delivery_type: "toss", commentary: tossText }));
        }
        // append the rest but filter out noisy lines
        for (const r of otherRows) {
          const txt = (r.commentary || r.comment || "").trim();
          if (!txt) continue;
          if (/comes into the attack/i.test(txt)) continue;
          container.appendChild(pushRow(r));
        }

        // final pass modifications
        removeComesIntoTheAttackNoise();
        await replaceTossIdsWithNames();

      } catch (err) {
        console.warn("loadCommentaryAndFixes error", err);
        container.innerHTML = '<div class="comment-row muted">Error loading commentary.</div>';
      }
    }

    async function tryFetchMatchObject(matchId) {
      // Try to find match object on page first
      const possible = window.match || window.matchData || window.__MATCH__ || window._match;
      if (possible) return possible;
      // Try to find a JSON blob in the DOM (common pattern)
      const el = $("#match-data-json") || document.querySelector('[type="application/json"][data-role="match"]');
      if (el) {
        try { return JSON.parse(el.textContent); } catch {}
      }
      // Else fall back to network request if endpoint available
      if (!matchId) return null;
      try {
        const res = await fetch(API.match(matchId));
        if (!res.ok) return null;
        return await res.json();
      } catch (e) {
        return null;
      }
    }

    function extractTossTextFromMatchObj(m) {
      if (!m) return null;
      // If result.toss.text exists prefer that
      if (m.result && m.result.toss && m.result.toss.text) return m.result.toss.text;
      // sim_state.toss.text
      if (m.sim_state && m.sim_state.toss && m.sim_state.toss.text) return m.sim_state.toss.text;
      // canonicalized shapes
      const canonical = (m.toss || (m.result && m.result.toss) || (m.sim_state && m.sim_state.toss));
      if (canonical) {
        const winner = canonical.winner || canonical.winner_team_id || canonical.winnerId;
        const decision = canonical.decision || canonical.elected || canonical.choice || "bat";
        if (winner) return `Toss: Team ${winner} won the toss and elected to ${decision}.`;
      }
      // last fallback stringification
      return null;
    }

    function getExistingTossTextFromPage() {
      const el = $("#toss-banner");
      if (!el) return null;
      const txt = (el.textContent || "").trim();
      if (!txt || txt.toLowerCase().indexOf("toss") === -1) return null;
      return txt;
    }

    function formatBallRow(r) {
      // fallback formatter when commentary text missing
      return `${r.innings || ''} ${r.over_number || ''}.${r.ball_in_over || ''} - ${r.commentary || ''}`.trim();
    }

    /* === Initialization / periodic refresh === */
    async function doInitialEnhancements() {
      // Wait a tick for the page to render server-populated content
      await wait(50);

      // If the banner currently contains a UUID, replace it
      await replaceTossIdsWithNames();

      // Load commentary and apply fixes (this will *not* remove real commentary you depend on)
      await loadCommentaryAndFixes();

      // Remove noisy lines if they still exist
      removeComesIntoTheAttackNoise();
    }

    // Kick off when DOM loaded
    document.addEventListener("DOMContentLoaded", () => {
      doInitialEnhancements().catch(e => console.error("enhancements error", e));

      // Wire refresh button if present
      const btn = document.getElementById("btn-refresh");
      if (btn) btn.addEventListener("click", async () => {
        await doInitialEnhancements();
      });

      // Auto-refresh interval (optional)
      const sel = document.getElementById("refresh-interval");
      if (sel) {
        let ms = 2000;
        sel.addEventListener("change", () => {
          const v = sel.value || "2s";
          if (v.endsWith("s")) ms = parseInt(v.slice(0,-1),10)*1000;
          // set up periodic refresh
          if (window.__enhancerInterval) clearInterval(window.__enhancerInterval);
          window.__enhancerInterval = setInterval(() => doInitialEnhancements().catch(()=>{}), ms);
        });
        // trigger initial
        sel.dispatchEvent(new Event("change"));
      }
    });

    // Expose small API for manual override if needed
    window.__tossEnhancer = {
      replaceTossIdsWithNames,
      loadCommentaryAndFixes,
      insertVirtualTossRowIfMissing,
      moveTossRowToTop
    };
  })();
  </script>
</body>
</html>
